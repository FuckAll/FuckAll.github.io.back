<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[重剑无锋，大巧不工。]]></title>
  <link href="http://blog.izgnod.com/atom.xml" rel="self"/>
  <link href="http://blog.izgnod.com/"/>
  <updated>2016-09-25T12:26:42+08:00</updated>
  <id>http://blog.izgnod.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Context]]></title>
    <link href="http://blog.izgnod.com/14746196382822.html"/>
    <updated>2016-09-23T16:33:58+08:00</updated>
    <id>http://blog.izgnod.com/14746196382822.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>WithCancel</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    //&quot;context&quot;
    &quot;context&quot;
    &quot;time&quot;
)

type otherContext struct {
    context.Context
    other string
}

func main() {
    // Background 声称一个context的根，是空的，但不是nil，根context是不能够Cancel的
    bkc := context.Background()
    // 生成一个Child Context ，带有Cancel，
    c1, cancel := context.WithCancel(bkc)

    // context 实现了String方法可以被Sprint格式化
    if got, want := fmt.Sprint(c1), &quot;context.Background.WithCancel&quot;; got != want {
        fmt.Errorf(&quot;c1.String() = %q want %q&quot;, got, want)
    }

    // 所有包含Context接口的数据类型都能够当做Context接口类型使用
    o := otherContext{c1, &quot;wonder&quot;}
    //o := otherContext{context.Background(), &quot;wonder&quot;}
    c2, _ := context.WithCancel(o)
    contexts := []context.Context{c1, o, c2}

    /*
            关系图
                bkc
                /
              c1(o)
              /
             c2
    */

    for i, c := range contexts {
        //Done返回值是一个 &lt;-chan struct{}， 返回nil说明这个Context是不能够用关闭的例如：Background生成的Context
        if d := c.Done(); d == nil {
            fmt.Errorf(&quot;c[%d].Done() == %v want non-nil&quot;, i, d)
        }
        // context关闭的原因，如果没有则返回nil， context 关闭之后会返回指定的内容
        if e := c.Err(); e != nil {
            fmt.Errorf(&quot;c[%d].Err() == %v want nil&quot;, i, e)
        }
        // c1和o是同一个context,所以前两个打印出来的内容一样
        tm := c.Done()
        fmt.Println(tm)

        select {
        //此处被block住，执行default，因为context并没有关闭
        case x := &lt;-c.Done():
            fmt.Errorf(&quot;&lt;-c.Done() == %v want nothing (it should block)&quot;, x)
        default:
        }
    }
    // 关闭c1,也就是关闭了o，那么c2也就被关闭了，关闭之后Done所返回的channel 也就关闭了， 关闭之后的channel能够一直取出值
    cancel()
    time.Sleep(100 * time.Millisecond) // let cancelation propagate

    //前面已经Done之后，再次执行Done
    for i, c := range contexts {
        select {
        // 关闭之后c.Done就不再是空
        case &lt;-c.Done():
        default:
            fmt.Errorf(&quot;&lt;-c[%d].Done() blocked, but shouldn&#39;t have&quot;, i)
        }
        if e := c.Err(); e != context.Canceled {
            fmt.Errorf(&quot;c[%d].Err() == %v want %v&quot;, i, e, context.Canceled)
        }
    }

}

</code></pre></li>
<li><p>TimeOut &amp;&amp; DeadLine</p>

<pre><code>    package main

import (
    &quot;fmt&quot;
    //&quot;context&quot;
    &quot;context&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

type otherContext struct {
    context.Context
}

func main() {

    // 50 millisecond 之后自动关闭
    c, _ := context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    if got, prefix := fmt.Sprint(c), &quot;context.Background.WithDeadline(&quot;; !strings.HasPrefix(got, prefix) {
        fmt.Errorf(&quot;c.String() = %q want prefix %q&quot;, got, prefix)
    }
    testDeadline(c, &quot;WithDeadline&quot;, time.Second)

    // 继承context的类型使用WithDeadline
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    o := otherContext{c}
    testDeadline(o, &quot;WithDeadline+otherContext&quot;, time.Second)

    // Parent Context 超时时间比 Child Context 超时时间短
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    o = otherContext{c}
    c, _ = context.WithDeadline(o, time.Now().Add(4*time.Second))
    // 结果为：Parent Context 超时
    testDeadline(c, &quot;WithDeadline+otherContext+WithDeadline&quot;, 2*time.Second)

    // 超时时间是负数，直接超时
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(-time.Millisecond))
    testDeadline(c, &quot;WithDeadline+inthepast&quot;, time.Second)

    // 超时时间是现在时间，直接超时
    c, _ = context.WithDeadline(context.Background(), time.Now())
    testDeadline(c, &quot;WithDeadline+now&quot;, time.Second)

    // WithTimeout

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    if got, prefix := fmt.Sprint(c), &quot;context.Background.WithDeadline(&quot;; !strings.HasPrefix(got, prefix) {
        fmt.Errorf(&quot;c.String() = %q want prefix %q&quot;, got, prefix)
    }
    testDeadline(c, &quot;WithTimeout&quot;, time.Second)

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    o = otherContext{c}
    testDeadline(o, &quot;WithTimeout+otherContext&quot;, time.Second)

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    o = otherContext{c}
    c, _ = context.WithTimeout(o, 3*time.Second)
    testDeadline(c, &quot;WithTimeout+otherContext+WithTimeout&quot;, 2*time.Second)

    // Cancel TimeOut
    // Cancel 能够立马生效
    c, _ = context.WithTimeout(context.Background(), time.Second)
    o = otherContext{c}
    c, cancel := context.WithTimeout(o, 2*time.Second)
    cancel()
    time.Sleep(100 * time.Millisecond) // let cancelation propagate
    select {
    case &lt;-c.Done():
    default:
        fmt.Errorf(&quot;&lt;-c.Done() blocked, but shouldn&#39;t have&quot;)
    }
    if e := c.Err(); e != context.Canceled {
        fmt.Errorf(&quot;c.Err() == %v want %v&quot;, e, context.Canceled)
    }

}

func testDeadline(c context.Context, name string, failAfter time.Duration) {
    select {
    case &lt;-time.After(failAfter):
        fmt.Errorf(&quot;%s: context should have timed out&quot;, name)
    case &lt;-c.Done():
        // context closed
    }
    if e := c.Err(); e != context.DeadlineExceeded {
        fmt.Errorf(&quot;%s: c.Err() == %v; want %v&quot;, name, e, context.DeadlineExceeded)
    }
}

</code></pre></li>
<li><p>WithValue</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;context&quot;
)

type otherContext struct {
    context.Context
}

type Key struct {
    name string
    age  int
}

func main() {

    sKey := Key{&quot;izgnod&quot;, 18}
    c0 := context.Background()
    fmt.Println(c0)

    c1 := context.WithValue(c0, &quot;k1&quot;, &quot;value1&quot;)
    fmt.Printf(&quot;key: k1 value:%s\n&quot;, c1.Value(&quot;k1&quot;))

    c2 := context.WithValue(c1, &quot;k2&quot;, sKey)
    switch t := c2.Value(&quot;k2&quot;).(type) {
    case Key:
        fmt.Printf(&quot;key: k2 value:Key{name:%s,age:%d}\n&quot;, t.name, t.age)
    default:
        fmt.Println(&quot;unknow&quot;)

    }
    fmt.Println(c2.Value(&quot;k1&quot;))

}
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 常用方法]]></title>
    <link href="http://blog.izgnod.com/14745419664301.html"/>
    <updated>2016-09-22T18:59:26+08:00</updated>
    <id>http://blog.izgnod.com/14745419664301.html</id>
    <content type="html"><![CDATA[
<p>进入git 目录，是工作目录(Working Directory)</p>

<p>git add 将文件加入到缓存区 ( Staged Snapshot ) <br/>
git commit 将文件加入到历史中 ( Commit History)</p>

<p>git reset --soft 将缓存区的文件，同步到指定的commit.<br/>
git reset --mixed 将工作目录同步到指定的commit，默认的是mixed.<br/>
git reset --hard 将工作目录和缓存区全部到指定的commit</p>

<p>常用操作：<br/>
git reset --mixed HEAD 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中<br/>
git reset --hard HEAD 舍弃所有的提交改动</p>

<p>git checkout commit_id 可以快速的切换到指定的commit </p>

<p>git revert 撤销已经提交的更改</p>

<p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki">https://github.com/geeeeeeeeek/git-recipes/wiki</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 控制routine]]></title>
    <link href="http://blog.izgnod.com/14745112452162.html"/>
    <updated>2016-09-22T10:27:25+08:00</updated>
    <id>http://blog.izgnod.com/14745112452162.html</id>
    <content type="html"><![CDATA[
<ol>
<li>select 控制routine</li>
</ol>

<pre><code>    func main() {
        // 这个地方要make，否则无法分配内存
        ch1 := make(chan bool, 1)
        ch2 := make(chan bool, 1)
        
        go test(ch1)
        time.Sleep(time.Second * 2)
        
        ch2 &lt;- false
        ch1 &lt;- false
        time.Sleep(time.Second * 2)
        
        ch1 &lt;- true
        time.Sleep(time.Second * 10)
    }

    func test(ch1 chan bool) {
        for {
            //fmt.Println(&quot;wonderful&quot;)
            //if &lt;-ch1 {
            //  fmt.Println(&quot;exit&quot;)
            //  return
            //}else {
            //  fmt.Println(&quot;else&quot;)
            //}
            select {
            case a := &lt;-ch1:
            if a {
            fmt.Println(&quot;exit&quot;)
            return
            } else {
            fmt.Println(&quot;nothing&quot;)
            }
            //default:
            //  fmt.Println(&quot;default&quot;)
            
            }
        }

 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Postgresql]]></title>
    <link href="http://blog.izgnod.com/14742795357312.html"/>
    <updated>2016-09-19T18:05:35+08:00</updated>
    <id>http://blog.izgnod.com/14742795357312.html</id>
    <content type="html"><![CDATA[
<ol>
<li>测试用例：</li>
</ol>

<pre><code>CREATE TABLE users (
id uuid primary key default gen_random_uuid(),
mobile text UNIQUE not null
);
INSERT INTO users (mobile) VALUES (&#39;86-1000000000&#39;)

</code></pre>

<ol>
<li>全在代码里：</li>
</ol>

<pre><code>package main

import (
    &quot;database/sql&quot;
    &quot;log&quot;

    //&quot;fmt&quot;
    &quot;fmt&quot;
    _ &quot;github.com/lib/pq&quot;
    &quot;time&quot;
    &quot;github.com/lib/pq&quot;
)

func main() {

    // 数据库连接
    db, err := sql.Open(&quot;postgres&quot;, &quot;user=postgres dbname=meidb sslmode=disable&quot;)
    if err != nil {
        log.Fatal(err)
    }

    // 连接数
    db.SetMaxOpenConns(10) // 最大连接数
    db.SetMaxIdleConns(5)  // 最大空闲数

    for i := 0; i &lt; 10; i++ {
        go func() {
            db.Ping()
        }()
    }
    //time.Sleep(10 * time.Second)

    // Exec 执行一次，没有具体值返回
    a, err := HowToExec(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Exec Result:&quot;, a)

    // Prepare
    for i := 0; i &lt; 10; i++ {
        go func() {
            p, err := HowToPrepare(db)
            if err != nil {
                log.Fatal(err)
            }
            fmt.Println(&quot;Prepare Result:&quot;, p)
        }()
    }
    time.Sleep(20 * time.Second)

    // QueryRow
    result, err := HowToQueryRow(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;QueryRow Result:&quot;, result)

    // Query
    total, results := HowToQuery(db)
    fmt.Println(&quot;Query Result:&quot;, total, results)


    // Begin
    HowToBegin(db)

    // 关闭连接
    defer db.Close()

}

func HowToExec(db *sql.DB) (int64, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;UPDATE users SET mobile=$1 WHERE mobile=$1;&quot;
    ret, err := db.Exec(q, m)
    if err != nil {
        return 0, err
    }
    r, err := ret.RowsAffected()
    ret.LastInsertId()
    if err != nil {
        return 0, err
    }
    return r, nil
}

func HowToPrepare(db *sql.DB) ([]string, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;SELECT id FROM users WHERE mobile=$1&quot;
    sm, err := db.Prepare(q)
    defer sm.Close()
    if err != nil {
        return []string{}, err
    }
    exec, err := sm.Exec(m)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    ret, err := exec.RowsAffected()
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare Exec Result:&quot;, ret)

    var queryTemp string
    query := sm.QueryRow(m)
    err = query.Scan(&amp;queryTemp)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare QueryRow Result:&quot;, queryTemp)

    sq, err := sm.Query(m)
    defer sq.Close()
    var re []string
    for sq.Next() {
        var tmp string
        err := sq.Scan(&amp;tmp)
        if err != nil {
            log.Println(err)
            return []string{}, nil
        }
        re = append(re, tmp)
    }
    fmt.Println(&quot;Prepare Query Result:&quot;, re)

    return re, nil
}

func HowToQueryRow(db *sql.DB) (string, error) {
    m := &quot;86-1000000000&quot;
    var temp string
    row := db.QueryRow(&quot;SELECT id FROM users WHERE mobile=$1&quot;, m)
    err := row.Scan(&amp;temp)
    if err != nil {
        if err == sql.ErrNoRows {
            // 没有查询到结果的返回,可以进行日志输出
            return temp, nil
        }
        // 出错，但是不是查询结果的问题
        return temp, err
    }
    return temp, nil
}

func HowToQuery(db *sql.DB) (total int, result []string) {
    q := &quot;SELECT id FROM users WHERE mobile=$1 ORDER BY id DESC OFFSET $2 LIMIT $3;&quot;
    qa := &quot;SELECT count(*) FROM users WHERE mobile=$1;&quot;
    m := &quot;86-1000000000&quot;
    var temp string

    // 查询总数
    row := db.QueryRow(qa, m)
    err := row.Scan(&amp;total)
    if err != nil {
        if err == sql.ErrNoRows {
            return 0, []string{}
        }
        log.Fatal(err)
    }

    // 结果查询
    rows, err := db.Query(q, m, 0, 20)
    defer rows.Close() // 将query关闭之后才能将连接放回连接池
    if err != nil {
        log.Fatal(err)
    }
    // 依次的准备好每一条查出的数据
    for rows.Next() {
        err := rows.Scan(&amp;temp)
        if err != nil {
            log.Fatal(err)

        }
        result = append(result, temp)
    }
    return total, result
}

func HowToBegin(db *sql.DB) {
    m := &quot;86-1000000001&quot;
    cm := &quot;86-1000000002&quot;
    txn, err := db.Begin()
    if err != nil {
        log.Println(err)
        return
    }

    stmt, err := txn.Prepare(pq.CopyIn(&quot;users&quot;, &quot;mobile&quot;))
    defer stmt.Close()

    if err != nil {
        log.Println(err)
        return
    }
    for i := 0; i &lt; 10; i++{
        _ , err :=stmt.Exec(m)
        if err != nil{
            log.Println(err)
            return
        }
    }

    _, err = stmt.Exec()
    if err != nil {
        log.Println(err)
        return
    }
    _, err = txn.Exec(&quot;UPDATE users SET mobile=$1&quot;,cm)
    if err != nil {
        log.Println(err)
        return
    }
    var id string
    var mob string
    err = txn.QueryRow(&quot;SELECT id, mobile FROM users WHERE mobile=$1&quot;, cm).Scan(&amp;id, &amp;mob)
    if err != nil {
        log.Println(err)
        return
    }
    fmt.Println(id, mob)

    // 事物提交
    err = txn.Commit()
    if err!= nil {
        log.Fatal()
    }

    //回滚
    //err = txn.Rollback()
    //if err!= nil {
    //  log.Fatal()
    //}

}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curl Http 测试]]></title>
    <link href="http://blog.izgnod.com/14742597754498.html"/>
    <updated>2016-09-19T12:36:15+08:00</updated>
    <id>http://blog.izgnod.com/14742597754498.html</id>
    <content type="html"><![CDATA[
<ol>
<li>常用参数</li>
</ol>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-X —request [GET POST PUT DELETE]</td>
<td>指定方法</td>
</tr>
<tr>
<td>-H —header</td>
<td>设定header</td>
</tr>
<tr>
<td>-i —include</td>
<td>显示response 中的header</td>
</tr>
<tr>
<td>-d —data</td>
<td>http的parameters</td>
</tr>
<tr>
<td>-v —verbose</td>
<td>输出详情</td>
</tr>
<tr>
<td>-u —user</td>
<td>使用者的账号，密码</td>
</tr>
<tr>
<td>-b —cookie</td>
<td>cookie</td>
</tr>
</tbody>
</table>

<p>用例：</p>

<pre><code>curl -X GET &quot;http://www.baidu.com/&quot;
curl -X POST &quot;http://www.baidu.com/&quot;
curl -X PUT &quot;http://www.baidu.com/&quot;
curl -X DELETE &quot;http://www.baidu.com/&quot;
</code></pre>

<ol>
<li><p>HEADER 信息<br/>
例如：（多个header对应多个-H参数）</p>

<pre><code>curl -v -i -H &quot;Content-Type: application/json&quot; &quot;http://www.baidu.com/&quot;
</code></pre></li>
<li><p>http 参数</p>

<ol>
<li>request parameter
例如：</li>
</ol>

<pre><code>    # 使用`&amp;`串接多个参数
    curl -X POST -d &quot;param1=value1&amp;param2=value2&quot;
    # 也可使用多個`-d`，效果同上
    curl -X POST -d &quot;param1=value1&quot; -d &quot;param2=value2&quot;
    curl -X POST -d &quot;param1=a 0space&quot;     
    # &quot;a space&quot; url encode後空白字元會編碼成&#39;%20&#39;為&quot;a%20space&quot;，編碼後的參數可以直接使用
    curl -X POST -d &quot;param1=a%20space&quot;     
</code></pre>

<ol>
<li>request json
例如：</li>
</ol>

<pre><code>    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -H &quot;Accept:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
    # 不加&quot;Accept:application/json&quot;也可以
    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 小技巧]]></title>
    <link href="http://blog.izgnod.com/14741728889918.html"/>
    <updated>2016-09-18T12:28:08+08:00</updated>
    <id>http://blog.izgnod.com/14741728889918.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">入参类型</h2>

<ul>
<li>如果是map，func，chan则不需要用指针，本身就是引用类型</li>
<li>如果是slice，方法中不需要修改，则不需要用指针</li>
<li>如果是func， 也需要方法内部替换的，就使用指针</li>
<li>如果是包含sysnc.Mutex的struct，则需要传指针，避免对象的复制</li>
<li>如果是大的array，struct，传指针比较好，如何评判是否够大，例如：比方法的对象还大。</li>
</ul>

<h2 id="toc_1">数组常见操作：</h2>

<ul>
<li>如何高效（不涉及到内存重新的分配）将数组向前移动：</li>
</ul>

<pre><code>    方法一：
    tmp := []int64{1,2,3}
    fmt.Printf(&quot;Befor :%p\n&quot;,&amp;tmp)
    copy(tmp, tmp[1:])
    tmp = tmp[:len(tmp)-1]
    fmt.Printf(&quot;After :%p\n&quot;,&amp;tmp)
    方法二：
    tmp1 := []int64{1,2,3}
    fmt.Printf(&quot;Befor :%p\n&quot;,&amp;tmp1)
    tmp1 = tmp1[1:len(tmp1)-1]
    fmt.Printf(&quot;After :%p\n&quot;,&amp;tmp1)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书]]></title>
    <link href="http://blog.izgnod.com/14734878748126.html"/>
    <updated>2016-09-10T14:11:14+08:00</updated>
    <id>http://blog.izgnod.com/14734878748126.html</id>
    <content type="html"><![CDATA[
<ol>
<li><a href="https://link.zhihu.com/?target=http%3A//www.quzhuanpan.com/source/search.action%3Fq%3Dkindle%2520%25E7%2594%25B5%25E5%25AD%2590%25E4%25B9%25A6%26currentPage%3D1">百度云资源搜索</a></li>
<li><a href="https://www.jiumodiary.com/">Jiumo E-Book Search 鸠摩搜书</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//readcolor.com">读远：发掘优质电子书资源，提供好书分享、下载与推送。支持mobi/epub/pdf/txt格式。</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//gen.lib.rus.ec">Library genesis 英文科学著作</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.gutenberg.org">Gutenberg 维基古腾堡计划</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Sort排序]]></title>
    <link href="http://blog.izgnod.com/14730511199413.html"/>
    <updated>2016-09-05T12:51:59+08:00</updated>
    <id>http://blog.izgnod.com/14730511199413.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang Sort 使用方法：</p>

<ol>
<li><p>实现Sort Interface 的三个方法</p>

<pre><code>Len()
Less(i, j int) bool
Swap(i, j int) 
</code></pre>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

//学生成绩结构体
type StuScore struct {
    //姓名
    name  string
    //成绩
    score int
}

type StuScores []StuScore

//Len()
func (s StuScores) Len() int {
    return len(s)
}

//Less():成绩将有低到高排序
func (s StuScores) Less(i, j int) bool {
    return s[i].score  &lt; s[j].score
}

//Swap()
func (s StuScores) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

func main() {
    stus := StuScores{
        {&quot;alan&quot;, 95},
        {&quot;hikerell&quot;, 91},
        {&quot;acmfly&quot;, 96},
        {&quot;leao&quot;, 90}}

    fmt.Println(&quot;Default:&quot;)
    //原始顺序
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }
    fmt.Println()
    //StuScores已经实现了sort.Interface接口
    sort.Sort(stus)

    fmt.Println(&quot;Sorted:&quot;)
    //排好序后的结构
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }

    //判断是否已经排好顺序，将会打印true
    fmt.Println(&quot;IS Sorted?&quot;, sort.IsSorted(stus))

    fmt.Println()
    // 排序翻转
    sort.Sort(sort.Reverse(stus))
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
        }
    }
</code></pre></li>
</ol></li>
<li><p>内部数据类型排序</p>

<ol>
<li><p>IntSlice, Float64Slice, StringSlice<br/>
举例：</p>

<pre><code>```
// 升序
s := []int{5,3,6,7,4}
sort.Ints(s)
fmt.Println(s) //将会输出[3 4 5 6 7]

// 降序
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Sort(sort.Reverse(sort.IntSlice(s)))
fmt.Println(s) //将会输出[6 5 4 3 2 1]

// 查找排序之后大于等于指定数字的位置
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Ints(s) //排序后的s为[1 2 3 4 5 6]
fmt.Println(sort.SearchInts(s, 3)) //将会输出2
```
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Label妙用]]></title>
    <link href="http://blog.izgnod.com/14729947807865.html"/>
    <updated>2016-09-04T21:13:00+08:00</updated>
    <id>http://blog.izgnod.com/14729947807865.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Label 使用</p>

<ol>
<li>Label 只能与 goto break continue 共同使用</li>
<li><p>使用限制：</p>

<ol>
<li><table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>效果</th>
</tr>
</thead>

<tbody>
<tr>
<td>goto</td>
<td>没有任何使用限制</td>
<td>跳转到任何地方</td>
</tr>
<tr>
<td>break </td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>终止循环，不再进入循环</td>
</tr>
<tr>
<td>continue</td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>暂停本轮循环</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>例如：</p>

<pre><code>func main() {
a := 1
LABEL1:

println(&quot;LABEL1&quot;)
println(&quot;inc a=&quot;, a)
a += 1

LABEL2:
 println(&quot;LABEL1&quot;) // 会报错的

for a &lt; 6 {
println(a)
if a == 3 {
a += 1
continue LABEL2
}
if a == 5 {
break
}
goto LABEL1
}

}
</code></pre></li>
<li><p>经典用法:<br/>
平常的循环嵌套：</p>

<pre><code>for _, item := range list.Items {
found := false

for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
found = true
break
}
... do some other work ...
}

if found {
continue
}

... do some other work ...
}
</code></pre>

<p>使用label的嵌套:</p>

<pre><code>OUTER:
for _, item := range list.Items {
for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
    continue OUTER
}
... do some other work ...
}
... do some other work ...
}
</code></pre>

<p><strong>Label放在for循环之前是表明跳出到哪一层的循环，不会影响到for循环，并不是每次跳跃之后都要重新执行for循环</strong></p></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法]]></title>
    <link href="http://blog.izgnod.com/14728851727641.html"/>
    <updated>2016-09-03T14:46:12+08:00</updated>
    <id>http://blog.izgnod.com/14728851727641.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>今天看golang源码关于字符串的时候发现strings.Replace方法使用的是Boyer-Moore算法</p>

<ol>
<li>推荐两个博文：

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">阮一峰字符串匹配的Boyer-Moore算法</a> </li>
<li><a href="http://www.cs.utexas.edu/%7Emoore/best-ideas/string-searching/index.html">Moore教授自己给出的例子</a></li>
</ol></li>
</ol></li>
<li><p>具体的实现：</p>

<ol>
<li>golang Strings 包中有实现</li>
<li><a href="https://github.com/ijibu/gobm">https://github.com/ijibu/gobm</a> 这个也是模仿strings包中的实现<br/></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 并发问题]]></title>
    <link href="http://blog.izgnod.com/14727913418128.html"/>
    <updated>2016-09-02T12:42:21+08:00</updated>
    <id>http://blog.izgnod.com/14727913418128.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>go关键字带来的并发</p>

<pre><code>func loop() {
// fmt.Println(&quot;wood&quot;)
    for i := 0; i &lt; 10; i++ {
    fmt.Printf(&quot;%d&quot;, i)
    }
}
func test() {
    loop()
    go loop()
    time.Sleep(time.Second)// 如果不等待，test会在goruntine没有开始执行就已经退出了。
}
</code></pre></li>
<li><p>信道带来的goroutine通信</p>

<ol>
<li><p>无缓存信道</p>

<pre><code>func test1() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
    messages &lt;- &quot;step 1&quot;
    }()
    fmt.Println(&quot;step 2&quot;)
    time.Sleep(time.Second)
}
</code></pre>

<p>注意：</p>

<ol>
<li><p>这种情况信道中放入东西，但是没有人取,能够正常退出。</p>

<pre><code>➜  src git:(master) ✗ go run hello.go
     go run hello.go
     step 1
     step 2
</code></pre></li>
<li><p>这种情况信道没有人放东西，但是有取得操作。所以会发生死锁。</p>

<pre><code>func test4() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
}()
&lt;-messages
}
</code></pre>

<pre><code>➜  src git:(master) ✗ go run hello.go
go run hello.go
step 1
fatal error: all goroutines are asleep - deadlock!
</code></pre></li>
<li><p>通过设置标志位控制执行顺序</p>

<pre><code> func test6() {
       complete := make(chan int)
         go func() {
        for i := 0; i &lt; 10; i++ {
               fmt.Printf(&quot;%d&quot;, i)

       }
       complete &lt;- 0

    }()
    fmt.Println(&quot;step 1&quot;)
    &lt;-complete
    fmt.Println(&quot;step 2&quot;)
}
</code></pre>

<p><strong>总结：也就是说，无缓存的信道，在存和取得时候都会临时挂起自己的goroutine,等到另外一端准备好之后才够恢复。<br/>
无缓冲的信道永远不会存储数据，只是负责数据的流通，所以数据要流转起来。</strong></p></li>
</ol></li>
</ol></li>
<li><p>channel 类型问题<br/>
channel的几种类型：chan type , chan&lt;- type , &lt;-chan type</p>

<ol>
<li><p>chan type 这种类型是可读又可以写的</p>

<pre><code>    package main
    import &quot;fmt&quot;

    func main() {
    test := []int{1, 2, 3}
    good := gen(test...)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    go func() {
    good &lt;- 4 // 这个地方必须是routine才可以向good中写入，如果good 类型是&lt;-chan int 是可以写入的，如果是chan&lt;- int只可以写入
    }()
    fmt.Println(&lt;-good)
    }

    func gen(nums ...int) chan int { //&lt;-chan int 只能读，chan&lt;- int 只能写
    out := make(chan int) // 没有缓存的chan，长度为1
    go func() {
    for _, n := range nums {
    out &lt;- n
    }
    // close(out) // 关闭之后则不能写入
    }()
    return out
    }
</code></pre></li>
</ol></li>
<li><p>死锁: 线程或者进程在等待资源的时候，一直无法得到所需要的就会陷入一种状态，这种状态就叫做死锁。</p>

<ol>
<li><p>死锁的几种情况</p>

<ol>
<li><p>在单独的gorunitine中操作无缓冲的信道，一定发生死锁。</p>

<pre><code>func main() {
    ch := make(chan int)
     ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开
    fmt.Println(&quot;This line code wont run&quot;) //在此行执行之前Go就会报死锁
}
</code></pre></li>
<li><p>多个无缓冲的信道相互依赖，可能会发生死锁。</p>

<pre><code>func test7() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        fmt.Println(&quot;wonder&quot;)
        ch1 &lt;- &lt;-ch2
    }()
    &lt;-ch1
}
</code></pre></li>
<li><p>多个无缓冲的信道，部分信道数据不能流动</p>

<pre><code> c, quit := make(chan int), make(chan int)
 go func() {
 c &lt;- 1  // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine
 quit &lt;- 0 // quit始终没有办法写入数据
 }()
 &lt;- quit // quit 等待数据的写
</code></pre></li>
</ol></li>
<li><p>解决死锁的方法：</p>

<ol>
<li><p>把没有放入的数据，赶紧放入，把没有取走的数据，赶紧取走。 </p>

<pre><code>c, quit := make(chan int), make(chan int)
go func() {
      c &lt;- 1
  quit &lt;- 0
}()
&lt;- c // 取走c的数据！
&lt;-quit
</code></pre></li>
<li><p>设置缓冲信道,这样信道就可以保存数据了，可以保存的数据长度为信道的长度，并且只有在存储的数据要超出信道的长度的时候，才会挂起，等待第一个数据被其他的goroutine拿走。</p>

<pre><code>func test() {
          ch := make(chan int, 3)
  ch &lt;- 1
  ch &lt;- 2
  ch &lt;- 3
  for v := range ch {
      fmt.Println(v)
  if len(ch) &lt;= 0 {
  break
  }
  }
      }
</code></pre>

<ol>
<li>上述就是设置了一个缓冲的信道，长度为3，最大能够录入3个，如果大于3个会阻塞，等待有channel被消费。</li>
<li><p>缓冲的信道是能够用range来遍历的，但是由于range不等到信道关闭是不会结束读取的，所以即使是ch长度为0，range也是会<br/>
继续去取，所以会报死锁的错误，所以通过判断ch的长度决定退出。(注意，这个如果是在信道存取的时候进行长度判断会出问题的。最好的方法是显示的关闭信道,<br/>
信道关闭之后，信道是只读的，不能写。)</p>

<pre><code>func test() {
        ch := make(chan int, 4)
        ch &lt;- 1
        ch &lt;- 2
        ch &lt;- 3
        close(ch)
        //ch &lt;- 4 //
            for v := range ch {
        fmt.Println(v)

        }
     }
</code></pre></li>
</ol></li>
</ol></li>
<li><p>并发 OR 并行</p>

<ol>
<li>并发区别于并行： 并发的意思是多个goroutine轮流的使用单核CPU，并行是每个goroutine都可以在另外单独的CPU上单独的运行。</li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 反射问题]]></title>
    <link href="http://blog.izgnod.com/14727911561394.html"/>
    <updated>2016-09-02T12:39:16+08:00</updated>
    <id>http://blog.izgnod.com/14727911561394.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>指针的反射</p>

<pre><code>func test6() {
        type User struct {
            Username string
        }
        type Admin struct {
            User
            title string
        }
        u := new(Admin)
        t := reflect.TypeOf(u)
        if t.Kind() == reflect.Ptr {
            t = t.Elem()
        }
}
</code></pre></li>
<li><p>结构体的反射</p>

<pre><code>// 反射结构体内容
func test5() {
        type User struct {
                Username string
        }
        type Admin struct {
                User
                title string
       }
       func() {
                var u Admin
                t := reflect.TypeOf(u)
                for i, n := 0, t.NumField(); i &lt; n; i++ {
                    f := t.Field(i)
                    fmt.Println(f.Name, f.Type)
                }
       }()
  }
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 指针问题]]></title>
    <link href="http://blog.izgnod.com/14727906220786.html"/>
    <updated>2016-09-02T12:30:22+08:00</updated>
    <id>http://blog.izgnod.com/14727906220786.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang指针<br><br/>
<strong>除了正常的指针之外，还有以下两种指针，一种是unsafe.Pointer指针，把任何的指针看成一个正常的指针，uintptr是将任何的一个指针都看成一个整数。</strong></p>

<ol>
<li><p>unsafe.Pointer指针</p>

<pre><code>// unsafe.Pointer 指针
    func test4() {
        type data struct {
            x [1024 * 100]byte
        }

        tmp := func() unsafe.Pointer {
             p := &amp;data{}
             return unsafe.Pointer(p)
        }

        const N = 10000
        cache := new([N]unsafe.Pointer)
        for i := 0; i &lt; N; i++ {
             cache[i] = tmp()
             time.Sleep(time.Millisecond)
        }
 }
</code></pre></li>
<li><p>uintptr指针(将指针看成一个整数)</p>

<pre><code>// uintptr 指针
func test3() {
    type data struct {
                x [1024 * 100]byte
    }

    tmp := func() uintptr {
            p := &amp;data{}
            return uintptr(unsafe.Pointer(p))
    }

    const N = 10000
    cache := new([N]uintptr)
    fmt.Println(reflect.TypeOf(cache))
    for i := 0; i &lt; N; i++ {
                cache[i] = tmp()
                time.Sleep(time.Millisecond)
        }
} 
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术类博客收集]]></title>
    <link href="http://blog.izgnod.com/14727777201831.html"/>
    <updated>2016-09-02T08:55:20+08:00</updated>
    <id>http://blog.izgnod.com/14727777201831.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">精华网站</h2>

<ol>
<li><a href="http://blog.jobbole.com/">伯乐在线</a>
主要是一些原创的聚合站点</li>
<li><a href="http://www.importnew.com/">ImportNew</a>
Java &amp; Android 技术分享</li>
<li><a href="http://segmentfault.com/">Segmentfault</a>
年轻开发者社区；最前沿的技术问答，最纯粹的技术切磋</li>
<li><a href="http://www.infoq.com/cn/">InfoQ</a>
InfoQ - 促进软件开发领域知识与创新的传播</li>
<li><a href="http://www.v2ex.com/">V2EX</a>
V2EX 是创意工作者们的社区。这里目前汇聚了超过 75000 名主要来自互联网行业、游戏行业和媒体行业的创意工作</li>
</ol>

<h2 id="toc_1">互联网公司团队博客</h2>

<ol>
<li><a href="http://www.jianshu.com/p/ca676b17603e">腾讯全端 AlloyTeam 团队 Blog</a>
Tencent  前端</li>
<li><a href="http://blogs.360.cn/">奇虎360技术博客</a></li>
<li><a href="http://tech.meituan.com/">美团技术团队</a></li>
<li><a href="http://tech.uc.cn/">UC技术博客</a></li>
<li><a href="http://www.jianshu.com/p/ca676b17603e">Tecent CDC</a></li>
</ol>

<h2 id="toc_2">业界大牛博客推荐</h2>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://coolshell.cn/">酷 壳</a></li>
<li><a href="http://it.deepinmind.com/">Java 译站</a></li>
<li><a href="http://www.aips.me/">周良的博客</a></li>
<li><a href="http://www.itzhai.com/">IT 宅</a></li>
<li><a href="http://macshuo.com/">MacTalk-池建强的随想录</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://yes2.me/">钟超&quot;s Blogs</a></li>
<li><a href="http://mindhacks.cn/">刘未鹏 | MIND HACKS</a></li>
<li><a href="http://www.raychase.net/">四火的唠叨</a></li>
<li><a href="http://blog.codingnow.com/">云风的 BLOG</a></li>
<li><a href="http://dbanotes.net/">Fenng</a></li>
<li><a href="http://beyondvincent.com/">破船之家</a></li>
<li><a href="http://blog.zhaojie.me/">老赵点滴 - 追求编程之美</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://bluedavy.me/">BlueDavy之技术Blog</a></li>
<li><a href="http://ifeve.com/">并发编程网</a></li>
<li><a href="http://timyang.net/">Tim&#39;s blog</a></li>
</ol>

<h2 id="toc_3">外部链接：</h2>

<ol>
<li><a href="http://blogwall.us/">博客墙</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[容器脚本]]></title>
    <link href="http://blog.izgnod.com/14726120122280.html"/>
    <updated>2016-08-31T10:53:32+08:00</updated>
    <id>http://blog.izgnod.com/14726120122280.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">容器清理脚本</h3>

<pre><code>#!/bin/sh

&gt;/tmp/run_image_ids.$$

DOCKER_BIN=/usr/bin/docker
LOG=/var/log/docker-cleanup.log

rm /tmp/run_image_ids.$$

echo &quot;$(date) start-----&quot; &gt;&gt;$LOG

$DOCKER_BIN ps --no-trunc -a -q | while read cid
do
  running=$($DOCKER_BIN inspect -f &#39;{{.State.Running}}&#39; $cid )
  if [ &quot;$running&quot;x = &quot;true&quot;x ]
  then
    id=$($DOCKER_BIN inspect -f &#39;{{.Image}}&#39; $cid )
    echo $id &gt;&gt;/tmp/run_image_ids.$$
    continue
  fi 
  fini=$($DOCKER_BIN inspect -f &#39;{{.State.FinishedAt}}&#39; $cid | awk -F. &#39;{print $1}&#39;)
  diff=$(expr $(date +&quot;%s&quot;) - $(date --date=&quot;$fini&quot; +&quot;%s&quot;))    
  #for MacOs 
  #diff=$(expr $(date +&quot;%s&quot;) - $(date -j -f %Y-%m-%dT%H:%M:%S &quot;$fini&quot; +&quot;%s&quot;))
  if [ $diff -gt 86400 ]
  then
     $DOCKER_BIN rm -v $cid &gt;&gt;$LOG 2&gt;&amp;1
  fi 
done


$DOCKER_BIN images --no-trunc | grep -v REPOSITORY | while read line
do
  repo_tag=$(echo $line | awk &#39;{print $1&quot;:&quot;$2}&#39;)
  image_id=$(echo $line | awk &#39;{print $3}&#39;)
  grep -q $image_id /tmp/run_image_ids.$$
  if [ $? -eq 0 ]
  then
    continue
  fi
  if [ &quot;$repo_tag&quot;x = &quot;&lt;none&gt;:&lt;none&gt;&quot;x ]
  then
    $DOCKER_BIN rmi $image_id &gt;&gt;$LOG 2&gt;&amp;1
  else
    $DOCKER_BIN rmi $repo_tag &gt;&gt;$LOG 2&gt;&amp;1
  fi
done

rm /tmp/run_image_ids.$$


echo &quot;$(date) end-----&quot; &gt;&gt;$LOG
</code></pre>

<p><strong>清理内容</strong><br/>
    1. 停止超过一天的容器<br/>
    2. 一天之内没有运行过容器的镜像</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 基础类型]]></title>
    <link href="http://blog.izgnod.com/14726074871676.html"/>
    <updated>2016-08-31T09:38:07+08:00</updated>
    <id>http://blog.izgnod.com/14726074871676.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量声明</h2>

<ol>
<li><p>不同基础类型的零值</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>

<tbody>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr>
<td>struct</td>
<td>nil</td>
</tr>
<tr>
<td>array</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
</tr>
</tbody>
</table></li>
<li><p>var a int 和 a := 0 的哲学</p>

<ol>
<li><p>var a int </p>

<p>var a int 可以用来声明局部和全局变量,如果不初始化那么就是对应的零值     var a int = 1 可以声明并且初始化</p></li>
<li><p>a := 0</p>

<p>a := 0 只能用来声明局部变量，不能够声明全局变量<br/>
a := 1 声明局部变量并且初始化</p></li>
<li><p>在局部的变量中 var 等价 : ; var 可以使用零值， : 是必须显示指明初始化值</p></li>
<li><p>我的使用习惯</p>

<ol>
<li>全局变量使用 var a int = 0 显示指明初始值</li>
<li>局部变量使用 a := 0 显示指明初始值</li>
</ol></li>
</ol>

<p><strong>注意：</strong><br/>
    var a int 也可以用做 var a = 0,效果是一样的，但是这里尽量的使用显示的指定类型和初始值</p></li>
</ol>

<h2 id="toc_1">字符串拼加性能问题</h2>

<ol>
<li>字符串拼加的三种方式：

<ol>
<li>+=</li>
<li>strings.Join()</li>
<li>bytes.Buffer</li>
</ol></li>
<li><p>比较：</p>

<pre><code>package main
import (
    &quot;fmt&quot;

    &quot;strings&quot;
    &quot;time&quot;
    &quot;bytes&quot;
)

func main() {
    var buffer bytes.Buffer

    s := time.Now()
    for i :=0; i &lt;100000; i++ {
        buffer.WriteString(&quot;test is here\n&quot;)
    }
    buffer.String() // 拼接结果
    e := time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    str := &quot;&quot;
    for i :=0; i &lt;100000; i++ {
        str += &quot;test is here\n&quot;
    }
    e = time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    var sl []string
    for i :=0; i &lt;100000; i++ {
        sl = append(sl, &quot;test is here\n&quot;)
    }
    strings.Join(sl, &quot;&quot;)
    e = time.Now()
    fmt.Println(&quot;taked time is&quot;, e.Sub(s).Seconds())
}
</code></pre>

<p><strong>运行结果</strong></p>

<pre><code>taked time is  0.0039795080000000005
taked time is  13.403575973
taked time is 0.017540489
</code></pre></li>
<li><p>[]byte 和 string </p>

<ol>
<li><p>golang 中的[]byte和string可以方便的转换</p>

<ol>
<li>[]byte -&gt; string
string([]byte) -&gt; string </li>
<li>string -&gt; []byte
[]byte(string) -&gt; []byte</li>
</ol>

<p><strong>golang中[]byte和string的方法基本上是一样的</strong></p></li>
<li><p>byte和string性能问题之buffer</p>

<ol>
<li>golang 中 bytes包中有Buffer类型以及相关方法

<ol>
<li>直接声明： var buffer bytes.Buffer</li>
<li>方法成成：</li>
</ol></li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_2">数组问题</h2>

<ol>
<li><p>声明Golang数组有两种方式</p>

<pre><code>    var arr1 = new([5]int)
    var arr2 [5]int
</code></pre>

<ol>
<li>Golang认为数组是一种值类型，但new的时候返回的是数组的指针。</li>
<li>第一种返回的是一个指针，传递的时候是不进行内存拷贝的。</li>
<li><p>第二种方式返回的是数组本身，传递的时候是进行内存拷贝的。<br/>
```<br/>
package main</p>

<p>import (<br/>
    &quot;fmt&quot;<br/>
)</p>

<p>func main() {<br/>
    var arr1 = new([5]int)  // 返回的是数组的地址<br/>
    var arr2 [5]int</p>

<pre><code>// 传地址进入函数，适用于需要修改数组或者数组较大
arrayAddr(arr1)
if arr1[0] != 1 {
    fmt.Printf(&quot;Want arr1[0]==1 but arr1[0]==%d&quot;, arr1[0])
}
// 传值进入函数，进行内存的拷贝
arrayVal(arr2)
if arr1[1] != 0 {
    fmt.Printf(&quot;Want arr1[1]==0 but arr1[1]==%d&quot;, arr1[1])
}
</code></pre>

<p>}</p>

<p>func arrayAddr(a *[5]int) {<br/>
    a[0] = 1<br/>
}</p>

<p>func arrayVal(a [5]int) {<br/>
    a[1] = 2<br/>
}</p></li>
</ol>

<pre><code></code></pre></li>
<li><p>切片问题<br/>
    <strong>切片在进行传递的时候也是指针传递</strong></p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    sliceAppend()

}
func sliceAppend() {
    // 声明一个数组,这个并不是Slice, len == cap
    var array = [...]int32{1, 2, 3, 4, 5, 6}

    // 不能使用append，append只能用给slice
    //array = append(array, 6)

    //struct    Slice
    //{             // must not move anything
    //  byte*   array;      // actual data
    //  uintgo  len;        // number of elements
    //  uintgo  cap;        // allocated number of elements
    //};
    //Slice 是指向一定长度的byte指针
</code></pre>

<p><a href="media/14726074871676/Golang%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.md">Golang 基础类型</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql语句集锦]]></title>
    <link href="http://blog.izgnod.com/14724588246571.html"/>
    <updated>2016-08-29T16:20:24+08:00</updated>
    <id>http://blog.izgnod.com/14724588246571.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>更正Jsonb中数据：</p>

<ol>
<li><img src="media/14724588246571/14724588641183.jpg" alt=""/></li>
</ol>

<p>将其中不合法的数据改成:[&quot;镭射祛斑&quot;,&quot;c10&quot;, &quot;白瓷娃娃&quot;, &quot;黄雀斑&quot;, &quot;雀斑&quot;, &quot;色斑&quot;,&quot;微整形&quot;]<br/>
语句：<br/>
其中的问题：多个字段在一个双引号中，其中是中文的逗号。</p>

<pre><code>UPDATE table_name SET tags=to_jsonb(string_to_array(jsonb_array_elements_text(tags),&#39;，&#39;)) WHERE tags!=&#39;null&#39;;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postgresql 备份与恢复]]></title>
    <link href="http://blog.izgnod.com/14724369503027.html"/>
    <updated>2016-08-29T10:15:50+08:00</updated>
    <id>http://blog.izgnod.com/14724369503027.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">备份和定时备份</h2>

<ol>
<li><p>备份命令</p>

<pre><code>pg_dump -h host_ip -p host_port -U datebase_user -d database_name -vF c -C -c -f test1.bkp test1 
-a 为只输出数据库中的数据（此处没有用）
-v 打出执行信息
-F 输出为指定的格式 c 为custom
-c dump的时候将drop database xxx 语句放入到dump的内容中
-C dump的时候将Create database xxx 语句放入到dump的内容中
-f 指定输出dump的名称
最后一个为数据库的名字
</code></pre></li>
<li><p>定时命令：</p>

<ol>
<li>脚本内容backup_db.sh(全量导出，这里导出的是自定义格式，只能够被全量恢复和部分恢复)</li>
</ol>

<pre><code>#/bin/bash
DATE=`date +&quot;%Y_%m_%d&quot;`
/usr/bin/pg_dump -U postgres -vF c -C -c -f /share/meidb_$DATE.bak meidb
## 备份到香港阿里云（这里要把key加好）
##chmod 777 /share/meidb_$DATE.bak
/usr/bin/scp -P hostPort -i /root/.ssh/id_rsa /share/meidb_$DATE.bak
root@Hostname:/backup/ &gt;&gt; /share/scp.log 2&gt;&amp;1
</code></pre></li>
</ol>

<h2 id="toc_1">如何恢复数据</h2>

<ol>
<li><p>全量数据恢复方法</p>

<ol>
<li><p>如果需要将原先的库进行删除并且重建</p>

<ol>
<li>执行命令：</li>
</ol>

<pre><code>pg_restore -h host_ip -p host_port -U postgres -d postgres -v -C  -c test1.bkp
</code></pre></li>
</ol></li>
<li><p>部分恢复的方法：</p>

<ol>
<li><p>创建恢复表的目录批量恢复方法：</p>

<ol>
<li>执行命创建恢复目录：</li>
</ol>

<pre><code>pg_restore -l test1db_2016_18_29.bkp -f table.lst
 -l, --list print summarized TOC of the archive
 -f, --file=FILENAME output file name
</code></pre>

<ol>
<li><p>修改恢复表目录：</p>

<ol>
<li><p>修改前内容例如：</p>

<pre><code>; Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
4170; 0 18551 TABLE DATA public activities postgres
4235; 0 0 SEQUENCE SET public activities_num_seq postgres
4172; 0 18564 TABLE DATA public activity_enrolls postgres
4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>将其余的注释，然后只留下需要恢复的表明即可：<br/>
    小技巧：vim替换模式:（:16,78s#<sup>4#;4#g）</sup><br/>
    修改后内容如下(例如要恢复表accounts)：</p>

<pre><code>;     Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
;4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
;4170; 0 18551 TABLE DATA public activities postgres
;4235; 0 0 SEQUENCE SET public activities_num_seq postgres
;4172; 0 18564 TABLE DATA public activity_enrolls postgres
;4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>恢复命令：</p>

<pre><code>pg_restore -U postgres -h hostname -p port -vaxd database_name -L table.lst test1
</code></pre></li>
</ol></li>
</ol></li>
<li><p>指定恢复表的方式</p>

<ol>
<li><p>恢复命令</p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account test1.bkp
</code></pre>

<p><strong>多个文件恢复</strong></p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account -t account_items  test.bkp
</code></pre></li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选股模型]]></title>
    <link href="http://blog.izgnod.com/14723863067284.html"/>
    <updated>2016-08-28T20:11:46+08:00</updated>
    <id>http://blog.izgnod.com/14723863067284.html</id>
    <content type="html"><![CDATA[
<pre><code>1. 长阳重炮
    2. 在低位温和放量之后出现了一根带量长阳（或涨停），同时成交量为上叉阳量托，马上直扑追涨。


    3. 量五日线2北，大阳线，实体的上沿可以做多，止损放到下沿
2. 吞并翻转
    3. 第一个交易日长阴（跌停）， 第二个交易日涨停，包容第一个交易日长阴。可以在第二个交易日涨停的刹那追涨买入
3. 螺旋桨
    4. 均线多头排列： 10日线在5日线以上至少
    5. 影线长度8%
    6. 量站上5日均量线
4. 牛熊不败
5. 三外有三
6. 喜鹊闹梅
    7. 
7. 切割线
    8. 一阳穿四线
    9. 量站上5日线
    10. 量比大于3%几率非常大
8. 故地重游
9. 开闸放水
10. 强势牛回头
11. 倒挂金钩
    12. 均线多头排列
    13. 高开3%左右
    14. 5日线附近可以开买
12. 蹄子线
13. 金字塔
14. 三步选股
15. 双锤筑底
16. 三只天鹅
17. 攻击线
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[股票线图]]></title>
    <link href="http://blog.izgnod.com/14723721762973.html"/>
    <updated>2016-08-28T16:16:16+08:00</updated>
    <id>http://blog.izgnod.com/14723721762973.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>k线</p>

<ol>
<li><p>锤子线和上吊线：</p>

<ol>
<li><p>定义： 锤子线和上吊线是相对于增长和下跌来说的，如果后市是上涨那么久叫锤子线，如果是下跌，那么就叫上吊线。如图：<br/>
<img src="media/14723721762973/14723767546699.jpg" alt=""/></p></li>
<li><p>使用前提： </p>

<ol>
<li>长时间的下跌，出现锤子线，或者长时间的上涨出现锤子线(上吊线)</li>
<li>下影线要是实体的2倍以上。</li>
<li>一般是没有上影线，如果有也是很短的</li>
</ol></li>
<li><p>如何使用：</p>

<ol>
<li>锤子线的出现时证明着走向有很大的可能进行逆转，当长期下跌，在底部出现锤子线，很可能已经找到支撑位，空头试图拉低，但是被多头拉回，空头的企图没有得逞，这就说明此时多头是占主。</li>
<li>何时出手，如果是锤子之后上涨趋势，那么第二天高开跳空或者是价位到达前一天锤子线实体的收盘价可出手，如果开始是下降趋势，然后反弹，反弹到前一天锤子线实体的收盘价可出手买入。如果是上吊线，那么最好早抛。 </li>
</ol></li>
</ol></li>
</ol></li>
<li><p>5日，10日，20日，30日，60日平均线</p></li>
<li></li>
</ol>

]]></content>
  </entry>
  
</feed>
