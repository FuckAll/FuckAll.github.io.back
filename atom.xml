<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[重剑无锋，大巧不工。]]></title>
  <link href="http://blog.izgnod.com/atom.xml" rel="self"/>
  <link href="http://blog.izgnod.com/"/>
  <updated>2016-11-25T10:33:52+08:00</updated>
  <id>http://blog.izgnod.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[最好的告别 -- 关于衰老与死亡]]></title>
    <link href="http://blog.izgnod.com/14799683000358.html"/>
    <updated>2016-11-24T14:18:20+08:00</updated>
    <id>http://blog.izgnod.com/14799683000358.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">大纲</h2>

<ul>
<li>
<a href="#toc_0">大纲</a>
<ul>
<li>
<a href="#toc_1">1. 独立 -- 现代化给了人们最大的自由，自助的生活方式</a>
</li>
<li>
<a href="#toc_2">2. 崩溃 -- 面对衰老的显示，并且能够从容对待</a>
<ul>
<li>
<a href="#toc_3">1. 人为何会衰老</a>
</li>
<li>
<a href="#toc_4">2. 医生为何会回避老年病</a>
<ul>
<li>
<a href="#toc_5">1. 收入偏低</a>
</li>
<li>
<a href="#toc_6">2. 老年病的复杂性</a>
</li>
<li>
<a href="#toc_7">3. 脚是老年人最大的危险</a>
</li>
<li>
<a href="#toc_8">4. 承认衰老才能够活的自然</a>
</li>
<li>
<a href="#toc_9">5.  老年病专家的晚年生活</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_10">3. 依赖 -- 我们为老做好了准备了么</a>
<ul>
<li>
<a href="#toc_11">1. 衰老是一系列的丧失</a>
</li>
<li>
<a href="#toc_12">2. 离开生活几十年的家</a>
</li>
<li>
<a href="#toc_13">3. 关在救济院的”犯人们“</a>
</li>
<li>
<a href="#toc_14">4. 应运而生的疗养院</a>
</li>
<li>
<a href="#toc_15">5. 老年的生活不能只是安全</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3 id="toc_1">1. 独立 -- 现代化给了人们最大的自由，自助的生活方式</h3>

<div id="1"></div>

<p>&emsp;&emsp; 现代化并没有降低老年人的地位，而只是降低了家庭的地位。它赋予人们，包括年轻人和老年人，一种更多自由（包括更少受制于其他几代人的自由）、自主、自助的生活方式。老年人不再受到崇拜，但那并不是因为被对年轻人的崇拜所代替，而是代之以对独立的自我崇拜。</p>

<h3 id="toc_2">2. 崩溃 -- 面对衰老的显示，并且能够从容对待</h3>

<div id="2"></div>

<blockquote>
<p>某种意义上，现代医学的进步带来两场革命：我们经历了生命过程的生物学转换，也经历了如何认识这一过程的文化转换。</p>
</blockquote>

<h4 id="toc_3">1. 人为何会衰老</h4>

<p>&emsp;&emsp;我们有一个多余的肾、一叶多余的肺、一副多余的性腺，以及多余的牙齿。细胞中的DNA在常规条件下经常受到损害，但是，我们的细胞有几个DNA修复系统。如果一个关键的基因永久性地损坏了，通常其附近就有额外的相同基因。而且，如果整个细胞都坏死了，那么，别的细胞就会填补进来。身体就是一下子就崩溃了。</p>

<h4 id="toc_4">2. 医生为何会回避老年病</h4>

<h5 id="toc_5">1. 收入偏低</h5>

<h5 id="toc_6">2. 老年病的复杂性</h5>

<p>&emsp;&emsp;对付老年病有一套技术——一套发达的专业技能。医生没有办法修复这些问题，但是可以进行干预与关怀。</p>

<h5 id="toc_7">3. 脚是老年人最大的危险</h5>

<h5 id="toc_8">4. 承认衰老才能够活的自然</h5>

<p>&emsp;&emsp;衰老是我们的宿命，死亡总有一天会降临。但是在我们体内的最后一个备用系统失灵之前，医学护理可以决定这条道路是猛然下降，还是舒展平缓地下降，使我们可以更长久地保持至关重要的生活能力。我们医学领域中的技术专家大多不考虑这个问题。我们擅长处理特定的、个别的问题：直肠癌、高血压、膝关节炎。交给我们一种病，我们能够采取一些措施。但是，给我们一个有高血压、膝关节炎以及其他各种病痛的老妇人，一个面临失去所喜欢的生活的危险的老妇人，我们几乎不知道该怎么办，往往只会把事情搞得更加糟糕。</p>

<h5 id="toc_9">5.  老年病专家的晚年生活</h5>

<ol>
<li>承认自己的衰老</li>
<li>持续的关注自己的健康，并且针对健康状况采取措施</li>
<li>继续履行自己的责任，以及自己对亲人的责任感</li>
</ol>

<h3 id="toc_10">3. 依赖 -- 我们为老做好了准备了么</h3>

<blockquote>
<p>衰老害怕的并不是死亡，而是死亡之前的种种状况；听力下降，记忆丧失，失去亲人，最好的朋友和固有的生活方式。老年不是一场战斗，而是一场屠杀。</p>
</blockquote>

<h4 id="toc_11">1. 衰老是一系列的丧失</h4>

<h4 id="toc_12">2. 离开生活几十年的家</h4>

<h4 id="toc_13">3. 关在救济院的”犯人们“</h4>

<blockquote>
<p>除非家人能够收容这样的人，否则，他们只得去通常所谓的救济院（poorhouse）或者济贫院（almshouse）。这类机构几百年前在欧洲和美国就有了。如果年事已高、需要帮助，但是又没有子女或者独立的财富可资依靠，那么，救济院就是唯一的庇护所。救济院是冷酷、可憎、地狱般的地方——这是当时的人的用词。这里住着各种类型的穷人——老乞丐、背运的移民、年轻的酒鬼、精神病人，其功能是令这些“犯人”改正他们被假定的酗酒放纵行为以及道德败坏。监管人员在布置工作的时候对老年乞丐一般比较宽大，但是，他们仍然像其他人一样被视为犯人。这些地方通常又脏又破。在这里，丈夫和妻子被分开，缺乏基本的身体保健。</p>
</blockquote>

<h4 id="toc_14">4. 应运而生的疗养院</h4>

<blockquote>
<p>这个转变的重要性怎么说都不过分。人类生存史上的大部分时候，从根本上来说，人只能凭自己的力量承受身体的痛苦。人们依靠自然、机遇及家庭和宗教。医药是可以尝试的另一个工具，跟治疗仪式、家庭疗法并无差别，也并非更有效。但是，随着医学变得更有力量，医院的产生带来不同的观念。你可以去一个地方，说：“把我治好。”你办好入院手续，把生命的每一个部分都交给医生和护士：你穿什么、吃什么、什么东西什么时候进入身体的不同部位。这个过程并不总是令人愉快，但是，对于迅速扩大的问题范围，它产生了前所未有的效果。医院学会了如何消除感染、如何切除肿瘤、如何修复断骨。他们可以治好疝气、心脏瓣膜闭合不全、胃溃疡大出血。在身体出问题或人老了的时候，医院成了人们的正常去处。</p>
</blockquote>

<p>&emsp;&emsp;随着医院越来越多，吸引着越来越多的衰弱人士，救济院逐渐的关闭，越来越多的衰弱人士进入到了医院中，但是医院并不能解决衰老问题，所以医院在政府的帮助下成立了专门看护的病房，形成了早期的疗养院，疗养院的雏形是为了给医院腾床位。并且，伴随着美国针对老年人和残疾人的健康保险制度，疗养院蓬勃的发展起来。但是随着疗养院的发展，一些问题也随着暴露出来，例如，安全问题。</p>

<h4 id="toc_15">5. 老年的生活不能只是安全</h4>

<blockquote>
<p>现代社会的基本运转原则是这样的：个人在不同的地方睡觉、玩乐、工作，有不同的同伴，接受不同权威的领导，没有一个总体的理性计划。<br/>
首先，生活的各个方面都是在同一个地方、在同一个中心权威领导之下进行的；其次，成员日常活动的各个方面都是和一大群人一起完成的；再次，日常活动的各个方面都是紧密安排的，一个活动紧接着另一个预先已经安排好的活动，活动的整个流程是由一套明确的正式规定和一群长官自上而下强行实施的；最后，各种强加的活动被整合为一套计划，据称是为了实现机构的官方目标。</p>
</blockquote>

<p>&emsp;&emsp;随着人的年龄增加，老年人越来越衰弱，被送入疗养院的老人，就如同进入了监狱一样，疗养院的目标是护理，也就是说，成批的老人在疗养院中要接受一些规则的管理，这样就使得老人感觉失去了身体的独立性。一旦失去了身体的独立性，有价值的生活和自由就不再存在。而一些老年人在持续进行着抗争，最终也不能够引起相关的重视。而这些也留给我们思考：在我们不再有能力保护自己的时候，如何才能够让我们的生活有意义。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读一本实用型的书--《如何阅读一本书》]]></title>
    <link href="http://blog.izgnod.com/14798734458692.html"/>
    <updated>2016-11-23T11:57:25+08:00</updated>
    <id>http://blog.izgnod.com/14798734458692.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1. 实用型书的基本原则：</h4>

<h5 id="toc_1">观点一： 任何的实用型的书都不能解决书中关心的实际问题，实际问题的解决只能靠实际行动解决。</h5>

<h6 id="toc_2">论据：</h6>

<pre><code>1. 由于不同的时间、地点、环境需要有不同的处理方法，实用型的书不能与你有一模一样的情况。
2. 理论性的原则只能归纳出出色的行事规则，但是这个需要有个人的判断力，在不同的情境中使用。
</code></pre>

<h4 id="toc_3">2.实用型书的类型</h4>

<ol>
<li>说明规则的，例如：说明书，烹饪书等</li>
<li>阐述理论的，例如：经济，政治等著作等</li>
</ol>

<h4 id="toc_4">3. 如何判断实用型书的类型。</h4>

<ol>
<li>说明规则的书，重在阐述一个可行的方法，一般会用比较肯定的语气，甚至是命令的语气说明方法的可行，也会写一些原理的方面的内容，为了衬托方法的确切可行。</li>
<li>阐述理论的书， 通过理论的阐述，告诉你一个比较通用的规则。这个的前提是读者能够同意并且能够接受作者的原理或者假设为前提。</li>
</ol>

<h4 id="toc_5">4. 如何对一本实用型的书进行提问</h4>

<ol>
<li>作者的目的是什么</li>
<li>他建议用什么样的方法达到</li>
</ol>

<h4 id="toc_6">5. 如何真正理解作者的目的</h4>

<ol>
<li>又能够了解作者的假设，作者的环境</li>
<li>在第一点的基础上，了解作者想要做什么，是否是你真正关心的话题</li>
<li>作者想要你做什么，以及他要你这么做的目的</li>
<li>内容是否真实, 作者描述的案例，宗旨，通过你的判断是否可以接受</li>
<li>同意作者的做法之后，也接受了作者的说法，开始将学到的东西辅助时间，并且形成子午的判断，这样就产生了我们和作者，和书之间的联系</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人选股]]></title>
    <link href="http://blog.izgnod.com/14764202917938.html"/>
    <updated>2016-10-14T12:44:51+08:00</updated>
    <id>http://blog.izgnod.com/14764202917938.html</id>
    <content type="html"><![CDATA[
<ol>
<li>要有3个程序，判断几率，用乘法</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker可持续化部署如何做]]></title>
    <link href="http://blog.izgnod.com/14761747399282.html"/>
    <updated>2016-10-11T16:32:19+08:00</updated>
    <id>http://blog.izgnod.com/14761747399282.html</id>
    <content type="html"><![CDATA[
<p>前言：一个团队是否需要整一套可持续化部署的工作流依我来看需要衡量几个方面。</p>

<pre><code>    1. 团队是否有时间。如果团队创业初期，业务进度比较急，那么先用脚本
    2. 做成之后团队收益高不高，业务简单，测试简单，部署方便，那么没有必要整这么一大套
    3. 普及，学习，使用成本高不高。可持续化部署工作流用起来更加麻烦，连教一遍都比较麻烦，那么要谨慎了
    4. 是否容易维护和扩展。如果做了太多的定制化，后期维护和扩展都相当麻烦，那么要注意了
</code></pre>

<ol>
<li><p>可持续发布对我们的收益。</p>

<ol>
<li>目前我们有34个微服务， </li>
</ol></li>
<li><p>什么是可持续发展</p></li>
<li><p>Jenkins能够做到哪些，还有什么不足的地方</p></li>
<li><p>工作流看起来是什么样子的</p></li>
<li><p>如何维护和扩展</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubernetes 监控]]></title>
    <link href="http://blog.izgnod.com/14750346668025.html"/>
    <updated>2016-09-28T11:51:06+08:00</updated>
    <id>http://blog.izgnod.com/14750346668025.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>可选的方案：</p>

<ol>
<li>Heapster + InfluxDB + Grafana </li>
<li>Prometheus + Grafana </li>
<li>Cadvisor+InfluxDB+Grafana </li>
</ol>

<p>最终选择：Prometheus + Grafana<br/>
原因是：Prometheus 对Kubernetes已经有了很好的支持，并且Grafana已经有了Prometheus的数据驱动。</p></li>
<li><p>总体规划<br/>
规划图：</p>

<p><img src="http://o9l83saod.bkt.clouddn.com/Prometheus%20+%20Grafana.jpg" alt="Prometheus + Grafana"/>      </p></li>
<li><p>部署：<br/>
前提：已经有了一个kubernetes集群。</p>

<ol>
<li><p>部署Prometheus，直接贴配置文件了（在kubernetes上直接部署）：</p>

<ol>
<li><p>配置文件(这里没有用https) prometheus-config.yaml</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
name: prometheus-config
data:
prometheus.yml: |
global:
  scrape_interval: 10s
  scrape_timeout: 10s
  evaluation_interval: 10s

scrape_configs:
- job_name: kubernetes-nodes-cadvisor
  scheme: https
  tls_config:
    insecure_skip_verify: true
  kubernetes_sd_configs:
  - api_servers:
    - http://kubernetes.default.svc/
    role: node
  relabel_configs:
  - action: labelmap
    regex: __meta_kubernetes_node_label_(.+)
  - source_labels: [__meta_kubernetes_role]
    action: replace
    target_label: kubernetes_role
  metric_relabel_configs:
  - source_labels: [id]
    action: replace
    regex: &#39;^/machine\.slice/machine-rkt\\x2d([^\\]+)\\.+/([^/]+)\.service$&#39;
    target_label: rkt_container_name
    replacement: &#39;${2}-${1}&#39;
  - source_labels: [id]
    action: replace
    regex: &#39;^/system\.slice/(.+)\.service$&#39;
    target_label: systemd_service_name
    replacement: &#39;${1}&#39;
- job_name: kubernetes-apiserver-cadvisor
  scheme: https
  tls_config:
    insecure_skip_verify: true
  kubernetes_sd_configs:
  - api_servers:
    - http://kubernetes.default.svc/
    role: apiserver
  relabel_configs:
  - action: labelmap
    regex: __meta_kubernetes_node_label_(.+)
  - source_labels: [__meta_kubernetes_role]
    action: replace
    target_label: kubernetes_role
</code></pre>

<p>参数参考：<a href="https://prometheus.io/docs/operating/configuration/#">https://prometheus.io/docs/operating/configuration/#</a><kubernetes_sd_config></p></li>
<li><p>部署配置：prometheus-deployment.yaml</p>

<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
labels:
    name: prometheus-deployment
    name: prometheus
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - image: index.tenxcloud.com/izgnod/prometheus:v1.0.1
        name: prometheus
        command:
        - &quot;/bin/prometheus&quot;
        args:
        - &quot;-config.file=/etc/prometheus/prometheus.yml&quot;
        - &quot;-storage.local.path=/prometheus&quot;
        - &quot;-storage.local.retention=24h&quot;
        ports:
        - containerPort: 9090
          protocol: TCP
        volumeMounts:
        - mountPath: &quot;/prometheus&quot;
          name: data
        - mountPath: &quot;/etc/prometheus&quot;
          name: config-volume
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
          limits:
            cpu: 500m
            memory: 2500Mi
      volumes:
      - emptyDir: {}
        name: data
      - configMap:
          name: prometheus-config
        name: config-volume
</code></pre></li>
</ol>

<p>注意：image 可以升级的时候改动</p>

<ol>
<li>运行如下命令</li>
</ol>

<pre><code>kubectl create -f prometheus-config.yaml
create -f prometheus-deployment.yaml
</code></pre></li>
<li><p>配置grafana</p>

<ol>
<li><p>docker直接部署或者直接用Kubernets,我这里就用docker直接部署了</p>

<pre><code>docker run -i -d -e &quot;GF_SERVER_ROOT_URL=http://grafana.xxx.com&quot; -e &quot;GF_SECURITY_ADMIN_PASSWORD=wothing&quot;  index.tenxcloud.com/izgnod/grafana:latest
</code></pre>

<p>注意：root url 环境变量一定要配你想解析的域名，也可以是一个地址。</p></li>
</ol></li>
<li><p>配置nginx，指向grafana</p>

<ol>
<li><p>nginx 简单配置：</p>

<pre><code>server {
    listen       80;
    server_name  grafana.xxx.com;

 location / {
     proxy_pass http://grafana_ip:3000;
     proxy_http_version 1.1;
     proxy_set_header Connection &quot;&quot;;
 }
}
</code></pre></li>
</ol></li>
<li><p>配置grafana</p>

<ol>
<li>首先配置database
配置详情参考官网：<a href="https://prometheus.io/docs/visualization/grafana/">https://prometheus.io/docs/visualization/grafana/</a></li>
<li>使用grafana模板
推荐：<a href="https://grafana.net/dashboards/315">https://grafana.net/dashboards/315</a></li>
</ol></li>
<li><p>效果展示：<br/>
<img src="http://o9l83saod.bkt.clouddn.com/grafana%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="grafana效果图"/></p></li>
</ol></li>
</ol>

<p>总结：对容器的监控，prometheus做了很好的集成，能够开箱即用，部署简单，指标全面。这部分是对整个kubernetes集群的监控，prometheus也有对业务打点的支持，后续再写一篇关于业务打点的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Context]]></title>
    <link href="http://blog.izgnod.com/14746196382822.html"/>
    <updated>2016-09-23T16:33:58+08:00</updated>
    <id>http://blog.izgnod.com/14746196382822.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>WithCancel</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    //&quot;context&quot;
    &quot;context&quot;
    &quot;time&quot;
)

type otherContext struct {
    context.Context
    other string
}

func main() {
    // Background 声称一个context的根，是空的，但不是nil，根context是不能够Cancel的
    bkc := context.Background()
    // 生成一个Child Context ，带有Cancel，
    c1, cancel := context.WithCancel(bkc)

    // context 实现了String方法可以被Sprint格式化
    if got, want := fmt.Sprint(c1), &quot;context.Background.WithCancel&quot;; got != want {
        fmt.Errorf(&quot;c1.String() = %q want %q&quot;, got, want)
    }

    // 所有包含Context接口的数据类型都能够当做Context接口类型使用
    o := otherContext{c1, &quot;wonder&quot;}
    //o := otherContext{context.Background(), &quot;wonder&quot;}
    c2, _ := context.WithCancel(o)
    contexts := []context.Context{c1, o, c2}

    /*
            关系图
                bkc
                /
              c1(o)
              /
             c2
    */

    for i, c := range contexts {
        //Done返回值是一个 &lt;-chan struct{}， 返回nil说明这个Context是不能够用关闭的例如：Background生成的Context
        if d := c.Done(); d == nil {
            fmt.Errorf(&quot;c[%d].Done() == %v want non-nil&quot;, i, d)
        }
        // context关闭的原因，如果没有则返回nil， context 关闭之后会返回指定的内容
        if e := c.Err(); e != nil {
            fmt.Errorf(&quot;c[%d].Err() == %v want nil&quot;, i, e)
        }
        // c1和o是同一个context,所以前两个打印出来的内容一样
        tm := c.Done()
        fmt.Println(tm)

        select {
        //此处被block住，执行default，因为context并没有关闭
        case x := &lt;-c.Done():
            fmt.Errorf(&quot;&lt;-c.Done() == %v want nothing (it should block)&quot;, x)
        default:
        }
    }
    // 关闭c1,也就是关闭了o，那么c2也就被关闭了，关闭之后Done所返回的channel 也就关闭了， 关闭之后的channel能够一直取出值
    cancel()
    time.Sleep(100 * time.Millisecond) // let cancelation propagate

    //前面已经Done之后，再次执行Done
    for i, c := range contexts {
        select {
        // 关闭之后c.Done就不再是空
        case &lt;-c.Done():
        default:
            fmt.Errorf(&quot;&lt;-c[%d].Done() blocked, but shouldn&#39;t have&quot;, i)
        }
        if e := c.Err(); e != context.Canceled {
            fmt.Errorf(&quot;c[%d].Err() == %v want %v&quot;, i, e, context.Canceled)
        }
    }

}

</code></pre></li>
<li><p>TimeOut &amp;&amp; DeadLine</p>

<pre><code>    package main

import (
    &quot;fmt&quot;
    //&quot;context&quot;
    &quot;context&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

type otherContext struct {
    context.Context
}

func main() {

    // 50 millisecond 之后自动关闭
    c, _ := context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    if got, prefix := fmt.Sprint(c), &quot;context.Background.WithDeadline(&quot;; !strings.HasPrefix(got, prefix) {
        fmt.Errorf(&quot;c.String() = %q want prefix %q&quot;, got, prefix)
    }
    testDeadline(c, &quot;WithDeadline&quot;, time.Second)

    // 继承context的类型使用WithDeadline
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    o := otherContext{c}
    testDeadline(o, &quot;WithDeadline+otherContext&quot;, time.Second)

    // Parent Context 超时时间比 Child Context 超时时间短
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(50*time.Millisecond))
    o = otherContext{c}
    c, _ = context.WithDeadline(o, time.Now().Add(4*time.Second))
    // 结果为：Parent Context 超时
    testDeadline(c, &quot;WithDeadline+otherContext+WithDeadline&quot;, 2*time.Second)

    // 超时时间是负数，直接超时
    c, _ = context.WithDeadline(context.Background(), time.Now().Add(-time.Millisecond))
    testDeadline(c, &quot;WithDeadline+inthepast&quot;, time.Second)

    // 超时时间是现在时间，直接超时
    c, _ = context.WithDeadline(context.Background(), time.Now())
    testDeadline(c, &quot;WithDeadline+now&quot;, time.Second)

    // WithTimeout

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    if got, prefix := fmt.Sprint(c), &quot;context.Background.WithDeadline(&quot;; !strings.HasPrefix(got, prefix) {
        fmt.Errorf(&quot;c.String() = %q want prefix %q&quot;, got, prefix)
    }
    testDeadline(c, &quot;WithTimeout&quot;, time.Second)

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    o = otherContext{c}
    testDeadline(o, &quot;WithTimeout+otherContext&quot;, time.Second)

    c, _ = context.WithTimeout(context.Background(), 50*time.Millisecond)
    o = otherContext{c}
    c, _ = context.WithTimeout(o, 3*time.Second)
    testDeadline(c, &quot;WithTimeout+otherContext+WithTimeout&quot;, 2*time.Second)

    // Cancel TimeOut
    // Cancel 能够立马生效
    c, _ = context.WithTimeout(context.Background(), time.Second)
    o = otherContext{c}
    c, cancel := context.WithTimeout(o, 2*time.Second)
    cancel()
    time.Sleep(100 * time.Millisecond) // let cancelation propagate
    select {
    case &lt;-c.Done():
    default:
        fmt.Errorf(&quot;&lt;-c.Done() blocked, but shouldn&#39;t have&quot;)
    }
    if e := c.Err(); e != context.Canceled {
        fmt.Errorf(&quot;c.Err() == %v want %v&quot;, e, context.Canceled)
    }

}

func testDeadline(c context.Context, name string, failAfter time.Duration) {
    select {
    case &lt;-time.After(failAfter):
        fmt.Errorf(&quot;%s: context should have timed out&quot;, name)
    case &lt;-c.Done():
        // context closed
    }
    if e := c.Err(); e != context.DeadlineExceeded {
        fmt.Errorf(&quot;%s: c.Err() == %v; want %v&quot;, name, e, context.DeadlineExceeded)
    }
}

</code></pre></li>
<li><p>WithValue</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;context&quot;
)

type otherContext struct {
    context.Context
}

type Key struct {
    name string
    age  int
}

func main() {

    sKey := Key{&quot;izgnod&quot;, 18}
    c0 := context.Background()
    fmt.Println(c0)

    c1 := context.WithValue(c0, &quot;k1&quot;, &quot;value1&quot;)
    fmt.Printf(&quot;key: k1 value:%s\n&quot;, c1.Value(&quot;k1&quot;))

    c2 := context.WithValue(c1, &quot;k2&quot;, sKey)
    switch t := c2.Value(&quot;k2&quot;).(type) {
    case Key:
        fmt.Printf(&quot;key: k2 value:Key{name:%s,age:%d}\n&quot;, t.name, t.age)
    default:
        fmt.Println(&quot;unknow&quot;)

    }
    fmt.Println(c2.Value(&quot;k1&quot;))

}
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 常用方法]]></title>
    <link href="http://blog.izgnod.com/14745419664301.html"/>
    <updated>2016-09-22T18:59:26+08:00</updated>
    <id>http://blog.izgnod.com/14745419664301.html</id>
    <content type="html"><![CDATA[
<p>进入git 目录，是工作目录(Working Directory)</p>

<p>git add 将文件加入到缓存区 ( Staged Snapshot ) <br/>
git commit 将文件加入到历史中 ( Commit History)</p>

<p>git reset --soft 将缓存区的文件，同步到指定的commit.<br/>
git reset --mixed 将工作目录同步到指定的commit，默认的是mixed.<br/>
git reset --hard 将工作目录和缓存区全部到指定的commit</p>

<p>常用操作：<br/>
git reset --mixed HEAD 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中<br/>
git reset --hard HEAD 舍弃所有的提交改动</p>

<p>git checkout commit_id 可以快速的切换到指定的commit </p>

<p>git revert 撤销已经提交的更改</p>

<p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki">https://github.com/geeeeeeeeek/git-recipes/wiki</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 控制routine]]></title>
    <link href="http://blog.izgnod.com/14745112452162.html"/>
    <updated>2016-09-22T10:27:25+08:00</updated>
    <id>http://blog.izgnod.com/14745112452162.html</id>
    <content type="html"><![CDATA[
<ol>
<li>select 控制routine</li>
</ol>

<pre><code>    func main() {
        // 这个地方要make，否则无法分配内存
        ch1 := make(chan bool, 1)
        ch2 := make(chan bool, 1)
        
        go test(ch1)
        time.Sleep(time.Second * 2)
        
        ch2 &lt;- false
        ch1 &lt;- false
        time.Sleep(time.Second * 2)
        
        ch1 &lt;- true
        time.Sleep(time.Second * 10)
    }

    func test(ch1 chan bool) {
        for {
            //fmt.Println(&quot;wonderful&quot;)
            //if &lt;-ch1 {
            //  fmt.Println(&quot;exit&quot;)
            //  return
            //}else {
            //  fmt.Println(&quot;else&quot;)
            //}
            select {
            case a := &lt;-ch1:
            if a {
            fmt.Println(&quot;exit&quot;)
            return
            } else {
            fmt.Println(&quot;nothing&quot;)
            }
            //default:
            //  fmt.Println(&quot;default&quot;)
            
            }
        }

 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Postgresql]]></title>
    <link href="http://blog.izgnod.com/14742795357312.html"/>
    <updated>2016-09-19T18:05:35+08:00</updated>
    <id>http://blog.izgnod.com/14742795357312.html</id>
    <content type="html"><![CDATA[
<ol>
<li>测试用例：</li>
</ol>

<pre><code>CREATE TABLE users (
id uuid primary key default gen_random_uuid(),
mobile text UNIQUE not null
);
INSERT INTO users (mobile) VALUES (&#39;86-1000000000&#39;)

</code></pre>

<ol>
<li>全在代码里：</li>
</ol>

<pre><code>package main

import (
    &quot;database/sql&quot;
    &quot;log&quot;

    //&quot;fmt&quot;
    &quot;fmt&quot;
    _ &quot;github.com/lib/pq&quot;
    &quot;time&quot;
    &quot;github.com/lib/pq&quot;
)

func main() {

    // 数据库连接
    db, err := sql.Open(&quot;postgres&quot;, &quot;user=postgres dbname=meidb sslmode=disable&quot;)
    if err != nil {
        log.Fatal(err)
    }

    // 连接数
    db.SetMaxOpenConns(10) // 最大连接数
    db.SetMaxIdleConns(5)  // 最大空闲数

    for i := 0; i &lt; 10; i++ {
        go func() {
            db.Ping()
        }()
    }
    //time.Sleep(10 * time.Second)

    // Exec 执行一次，没有具体值返回
    a, err := HowToExec(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Exec Result:&quot;, a)

    // Prepare
    for i := 0; i &lt; 10; i++ {
        go func() {
            p, err := HowToPrepare(db)
            if err != nil {
                log.Fatal(err)
            }
            fmt.Println(&quot;Prepare Result:&quot;, p)
        }()
    }
    time.Sleep(20 * time.Second)

    // QueryRow
    result, err := HowToQueryRow(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;QueryRow Result:&quot;, result)

    // Query
    total, results := HowToQuery(db)
    fmt.Println(&quot;Query Result:&quot;, total, results)


    // Begin
    HowToBegin(db)

    // 关闭连接
    defer db.Close()

}

func HowToExec(db *sql.DB) (int64, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;UPDATE users SET mobile=$1 WHERE mobile=$1;&quot;
    ret, err := db.Exec(q, m)
    if err != nil {
        return 0, err
    }
    r, err := ret.RowsAffected()
    ret.LastInsertId()
    if err != nil {
        return 0, err
    }
    return r, nil
}

func HowToPrepare(db *sql.DB) ([]string, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;SELECT id FROM users WHERE mobile=$1&quot;
    sm, err := db.Prepare(q)
    defer sm.Close()
    if err != nil {
        return []string{}, err
    }
    exec, err := sm.Exec(m)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    ret, err := exec.RowsAffected()
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare Exec Result:&quot;, ret)

    var queryTemp string
    query := sm.QueryRow(m)
    err = query.Scan(&amp;queryTemp)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare QueryRow Result:&quot;, queryTemp)

    sq, err := sm.Query(m)
    defer sq.Close()
    var re []string
    for sq.Next() {
        var tmp string
        err := sq.Scan(&amp;tmp)
        if err != nil {
            log.Println(err)
            return []string{}, nil
        }
        re = append(re, tmp)
    }
    fmt.Println(&quot;Prepare Query Result:&quot;, re)

    return re, nil
}

func HowToQueryRow(db *sql.DB) (string, error) {
    m := &quot;86-1000000000&quot;
    var temp string
    row := db.QueryRow(&quot;SELECT id FROM users WHERE mobile=$1&quot;, m)
    err := row.Scan(&amp;temp)
    if err != nil {
        if err == sql.ErrNoRows {
            // 没有查询到结果的返回,可以进行日志输出
            return temp, nil
        }
        // 出错，但是不是查询结果的问题
        return temp, err
    }
    return temp, nil
}

func HowToQuery(db *sql.DB) (total int, result []string) {
    q := &quot;SELECT id FROM users WHERE mobile=$1 ORDER BY id DESC OFFSET $2 LIMIT $3;&quot;
    qa := &quot;SELECT count(*) FROM users WHERE mobile=$1;&quot;
    m := &quot;86-1000000000&quot;
    var temp string

    // 查询总数
    row := db.QueryRow(qa, m)
    err := row.Scan(&amp;total)
    if err != nil {
        if err == sql.ErrNoRows {
            return 0, []string{}
        }
        log.Fatal(err)
    }

    // 结果查询
    rows, err := db.Query(q, m, 0, 20)
    defer rows.Close() // 将query关闭之后才能将连接放回连接池
    if err != nil {
        log.Fatal(err)
    }
    // 依次的准备好每一条查出的数据
    for rows.Next() {
        err := rows.Scan(&amp;temp)
        if err != nil {
            log.Fatal(err)

        }
        result = append(result, temp)
    }
    return total, result
}

func HowToBegin(db *sql.DB) {
    m := &quot;86-1000000001&quot;
    cm := &quot;86-1000000002&quot;
    txn, err := db.Begin()
    if err != nil {
        log.Println(err)
        return
    }

    stmt, err := txn.Prepare(pq.CopyIn(&quot;users&quot;, &quot;mobile&quot;))
    defer stmt.Close()

    if err != nil {
        log.Println(err)
        return
    }
    for i := 0; i &lt; 10; i++{
        _ , err :=stmt.Exec(m)
        if err != nil{
            log.Println(err)
            return
        }
    }

    _, err = stmt.Exec()
    if err != nil {
        log.Println(err)
        return
    }
    _, err = txn.Exec(&quot;UPDATE users SET mobile=$1&quot;,cm)
    if err != nil {
        log.Println(err)
        return
    }
    var id string
    var mob string
    err = txn.QueryRow(&quot;SELECT id, mobile FROM users WHERE mobile=$1&quot;, cm).Scan(&amp;id, &amp;mob)
    if err != nil {
        log.Println(err)
        return
    }
    fmt.Println(id, mob)

    // 事物提交
    err = txn.Commit()
    if err!= nil {
        log.Fatal()
    }

    //回滚
    //err = txn.Rollback()
    //if err!= nil {
    //  log.Fatal()
    //}

}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curl Http 测试]]></title>
    <link href="http://blog.izgnod.com/14742597754498.html"/>
    <updated>2016-09-19T12:36:15+08:00</updated>
    <id>http://blog.izgnod.com/14742597754498.html</id>
    <content type="html"><![CDATA[
<ol>
<li>常用参数</li>
</ol>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-X —request [GET POST PUT DELETE]</td>
<td>指定方法</td>
</tr>
<tr>
<td>-H —header</td>
<td>设定header</td>
</tr>
<tr>
<td>-i —include</td>
<td>显示response 中的header</td>
</tr>
<tr>
<td>-d —data</td>
<td>http的parameters</td>
</tr>
<tr>
<td>-v —verbose</td>
<td>输出详情</td>
</tr>
<tr>
<td>-u —user</td>
<td>使用者的账号，密码</td>
</tr>
<tr>
<td>-b —cookie</td>
<td>cookie</td>
</tr>
</tbody>
</table>

<p>用例：</p>

<pre><code>curl -X GET &quot;http://www.baidu.com/&quot;
curl -X POST &quot;http://www.baidu.com/&quot;
curl -X PUT &quot;http://www.baidu.com/&quot;
curl -X DELETE &quot;http://www.baidu.com/&quot;
</code></pre>

<ol>
<li><p>HEADER 信息<br/>
例如：（多个header对应多个-H参数）</p>

<pre><code>curl -v -i -H &quot;Content-Type: application/json&quot; &quot;http://www.baidu.com/&quot;
</code></pre></li>
<li><p>http 参数</p>

<ol>
<li>request parameter
例如：</li>
</ol>

<pre><code>    # 使用`&amp;`串接多个参数
    curl -X POST -d &quot;param1=value1&amp;param2=value2&quot;
    # 也可使用多個`-d`，效果同上
    curl -X POST -d &quot;param1=value1&quot; -d &quot;param2=value2&quot;
    curl -X POST -d &quot;param1=a 0space&quot;     
    # &quot;a space&quot; url encode後空白字元會編碼成&#39;%20&#39;為&quot;a%20space&quot;，編碼後的參數可以直接使用
    curl -X POST -d &quot;param1=a%20space&quot;     
</code></pre>

<ol>
<li>request json
例如：</li>
</ol>

<pre><code>    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -H &quot;Accept:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
    # 不加&quot;Accept:application/json&quot;也可以
    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 小技巧]]></title>
    <link href="http://blog.izgnod.com/14741728889918.html"/>
    <updated>2016-09-18T12:28:08+08:00</updated>
    <id>http://blog.izgnod.com/14741728889918.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">入参类型</h2>

<ul>
<li>如果是map，func，chan则不需要用指针，本身就是引用类型</li>
<li>如果是slice，方法中不需要修改，则不需要用指针</li>
<li>如果是func， 也需要方法内部替换的，就使用指针</li>
<li>如果是包含sysnc.Mutex的struct，则需要传指针，避免对象的复制</li>
<li>如果是大的array，struct，传指针比较好，如何评判是否够大，例如：比方法的对象还大。</li>
</ul>

<h2 id="toc_1">数组常见操作：</h2>

<ul>
<li>如何高效（不涉及到内存重新的分配）将数组向前移动：</li>
</ul>

<pre><code>    方法一：
    tmp := []int64{1,2,3}
    fmt.Printf(&quot;Befor :%p\n&quot;,&amp;tmp)
    copy(tmp, tmp[1:])
    tmp = tmp[:len(tmp)-1]
    fmt.Printf(&quot;After :%p\n&quot;,&amp;tmp)
    方法二：
    tmp1 := []int64{1,2,3}
    fmt.Printf(&quot;Befor :%p\n&quot;,&amp;tmp1)
    tmp1 = tmp1[1:len(tmp1)-1]
    fmt.Printf(&quot;After :%p\n&quot;,&amp;tmp1)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书]]></title>
    <link href="http://blog.izgnod.com/14734878748126.html"/>
    <updated>2016-09-10T14:11:14+08:00</updated>
    <id>http://blog.izgnod.com/14734878748126.html</id>
    <content type="html"><![CDATA[
<ol>
<li><a href="https://link.zhihu.com/?target=http%3A//www.quzhuanpan.com/source/search.action%3Fq%3Dkindle%2520%25E7%2594%25B5%25E5%25AD%2590%25E4%25B9%25A6%26currentPage%3D1">百度云资源搜索</a></li>
<li><a href="https://www.jiumodiary.com/">Jiumo E-Book Search 鸠摩搜书</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//readcolor.com">读远：发掘优质电子书资源，提供好书分享、下载与推送。支持mobi/epub/pdf/txt格式。</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//gen.lib.rus.ec">Library genesis 英文科学著作</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.gutenberg.org">Gutenberg 维基古腾堡计划</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Sort排序]]></title>
    <link href="http://blog.izgnod.com/14730511199413.html"/>
    <updated>2016-09-05T12:51:59+08:00</updated>
    <id>http://blog.izgnod.com/14730511199413.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang Sort 使用方法：</p>

<ol>
<li><p>实现Sort Interface 的三个方法</p>

<pre><code>Len()
Less(i, j int) bool
Swap(i, j int) 
</code></pre>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

//学生成绩结构体
type StuScore struct {
    //姓名
    name  string
    //成绩
    score int
}

type StuScores []StuScore

//Len()
func (s StuScores) Len() int {
    return len(s)
}

//Less():成绩将有低到高排序
func (s StuScores) Less(i, j int) bool {
    return s[i].score  &lt; s[j].score
}

//Swap()
func (s StuScores) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

func main() {
    stus := StuScores{
        {&quot;alan&quot;, 95},
        {&quot;hikerell&quot;, 91},
        {&quot;acmfly&quot;, 96},
        {&quot;leao&quot;, 90}}

    fmt.Println(&quot;Default:&quot;)
    //原始顺序
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }
    fmt.Println()
    //StuScores已经实现了sort.Interface接口
    sort.Sort(stus)

    fmt.Println(&quot;Sorted:&quot;)
    //排好序后的结构
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }

    //判断是否已经排好顺序，将会打印true
    fmt.Println(&quot;IS Sorted?&quot;, sort.IsSorted(stus))

    fmt.Println()
    // 排序翻转
    sort.Sort(sort.Reverse(stus))
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
        }
    }
</code></pre></li>
</ol></li>
<li><p>内部数据类型排序</p>

<ol>
<li><p>IntSlice, Float64Slice, StringSlice<br/>
举例：</p>

<pre><code>```
// 升序
s := []int{5,3,6,7,4}
sort.Ints(s)
fmt.Println(s) //将会输出[3 4 5 6 7]

// 降序
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Sort(sort.Reverse(sort.IntSlice(s)))
fmt.Println(s) //将会输出[6 5 4 3 2 1]

// 查找排序之后大于等于指定数字的位置
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Ints(s) //排序后的s为[1 2 3 4 5 6]
fmt.Println(sort.SearchInts(s, 3)) //将会输出2
```
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Label妙用]]></title>
    <link href="http://blog.izgnod.com/14729947807865.html"/>
    <updated>2016-09-04T21:13:00+08:00</updated>
    <id>http://blog.izgnod.com/14729947807865.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Label 使用</p>

<ol>
<li>Label 只能与 goto break continue 共同使用</li>
<li><p>使用限制：</p>

<ol>
<li><table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>效果</th>
</tr>
</thead>

<tbody>
<tr>
<td>goto</td>
<td>没有任何使用限制</td>
<td>跳转到任何地方</td>
</tr>
<tr>
<td>break </td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>终止循环，不再进入循环</td>
</tr>
<tr>
<td>continue</td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>暂停本轮循环</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>例如：</p>

<pre><code>func main() {
a := 1
LABEL1:

println(&quot;LABEL1&quot;)
println(&quot;inc a=&quot;, a)
a += 1

LABEL2:
 println(&quot;LABEL1&quot;) // 会报错的

for a &lt; 6 {
println(a)
if a == 3 {
a += 1
continue LABEL2
}
if a == 5 {
break
}
goto LABEL1
}

}
</code></pre></li>
<li><p>经典用法:<br/>
平常的循环嵌套：</p>

<pre><code>for _, item := range list.Items {
found := false

for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
found = true
break
}
... do some other work ...
}

if found {
continue
}

... do some other work ...
}
</code></pre>

<p>使用label的嵌套:</p>

<pre><code>OUTER:
for _, item := range list.Items {
for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
    continue OUTER
}
... do some other work ...
}
... do some other work ...
}
</code></pre>

<p><strong>Label放在for循环之前是表明跳出到哪一层的循环，不会影响到for循环，并不是每次跳跃之后都要重新执行for循环</strong></p></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法]]></title>
    <link href="http://blog.izgnod.com/14728851727641.html"/>
    <updated>2016-09-03T14:46:12+08:00</updated>
    <id>http://blog.izgnod.com/14728851727641.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>今天看golang源码关于字符串的时候发现strings.Replace方法使用的是Boyer-Moore算法</p>

<ol>
<li>推荐两个博文：

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">阮一峰字符串匹配的Boyer-Moore算法</a> </li>
<li><a href="http://www.cs.utexas.edu/%7Emoore/best-ideas/string-searching/index.html">Moore教授自己给出的例子</a></li>
</ol></li>
</ol></li>
<li><p>具体的实现：</p>

<ol>
<li>golang Strings 包中有实现</li>
<li><a href="https://github.com/ijibu/gobm">https://github.com/ijibu/gobm</a> 这个也是模仿strings包中的实现<br/></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 并发问题]]></title>
    <link href="http://blog.izgnod.com/14727913418128.html"/>
    <updated>2016-09-02T12:42:21+08:00</updated>
    <id>http://blog.izgnod.com/14727913418128.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>go关键字带来的并发</p>

<pre><code>func loop() {
// fmt.Println(&quot;wood&quot;)
    for i := 0; i &lt; 10; i++ {
    fmt.Printf(&quot;%d&quot;, i)
    }
}
func test() {
    loop()
    go loop()
    time.Sleep(time.Second)// 如果不等待，test会在goruntine没有开始执行就已经退出了。
}
</code></pre></li>
<li><p>信道带来的goroutine通信</p>

<ol>
<li><p>无缓存信道</p>

<pre><code>func test1() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
    messages &lt;- &quot;step 1&quot;
    }()
    fmt.Println(&quot;step 2&quot;)
    time.Sleep(time.Second)
}
</code></pre>

<p>注意：</p>

<ol>
<li><p>这种情况信道中放入东西，但是没有人取,能够正常退出。</p>

<pre><code>➜  src git:(master) ✗ go run hello.go
     go run hello.go
     step 1
     step 2
</code></pre></li>
<li><p>这种情况信道没有人放东西，但是有取得操作。所以会发生死锁。</p>

<pre><code>func test4() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
}()
&lt;-messages
}
</code></pre>

<pre><code>➜  src git:(master) ✗ go run hello.go
go run hello.go
step 1
fatal error: all goroutines are asleep - deadlock!
</code></pre></li>
<li><p>通过设置标志位控制执行顺序</p>

<pre><code> func test6() {
       complete := make(chan int)
         go func() {
        for i := 0; i &lt; 10; i++ {
               fmt.Printf(&quot;%d&quot;, i)

       }
       complete &lt;- 0

    }()
    fmt.Println(&quot;step 1&quot;)
    &lt;-complete
    fmt.Println(&quot;step 2&quot;)
}
</code></pre>

<p><strong>总结：也就是说，无缓存的信道，在存和取得时候都会临时挂起自己的goroutine,等到另外一端准备好之后才够恢复。<br/>
无缓冲的信道永远不会存储数据，只是负责数据的流通，所以数据要流转起来。</strong></p></li>
</ol></li>
</ol></li>
<li><p>channel 类型问题<br/>
channel的几种类型：chan type , chan&lt;- type , &lt;-chan type</p>

<ol>
<li><p>chan type 这种类型是可读又可以写的</p>

<pre><code>    package main
    import &quot;fmt&quot;

    func main() {
    test := []int{1, 2, 3}
    good := gen(test...)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    go func() {
    good &lt;- 4 // 这个地方必须是routine才可以向good中写入，如果good 类型是&lt;-chan int 是可以写入的，如果是chan&lt;- int只可以写入
    }()
    fmt.Println(&lt;-good)
    }

    func gen(nums ...int) chan int { //&lt;-chan int 只能读，chan&lt;- int 只能写
    out := make(chan int) // 没有缓存的chan，长度为1
    go func() {
    for _, n := range nums {
    out &lt;- n
    }
    // close(out) // 关闭之后则不能写入
    }()
    return out
    }
</code></pre></li>
</ol></li>
<li><p>死锁: 线程或者进程在等待资源的时候，一直无法得到所需要的就会陷入一种状态，这种状态就叫做死锁。</p>

<ol>
<li><p>死锁的几种情况</p>

<ol>
<li><p>在单独的gorunitine中操作无缓冲的信道，一定发生死锁。</p>

<pre><code>func main() {
    ch := make(chan int)
     ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开
    fmt.Println(&quot;This line code wont run&quot;) //在此行执行之前Go就会报死锁
}
</code></pre></li>
<li><p>多个无缓冲的信道相互依赖，可能会发生死锁。</p>

<pre><code>func test7() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        fmt.Println(&quot;wonder&quot;)
        ch1 &lt;- &lt;-ch2
    }()
    &lt;-ch1
}
</code></pre></li>
<li><p>多个无缓冲的信道，部分信道数据不能流动</p>

<pre><code> c, quit := make(chan int), make(chan int)
 go func() {
 c &lt;- 1  // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine
 quit &lt;- 0 // quit始终没有办法写入数据
 }()
 &lt;- quit // quit 等待数据的写
</code></pre></li>
</ol></li>
<li><p>解决死锁的方法：</p>

<ol>
<li><p>把没有放入的数据，赶紧放入，把没有取走的数据，赶紧取走。 </p>

<pre><code>c, quit := make(chan int), make(chan int)
go func() {
      c &lt;- 1
  quit &lt;- 0
}()
&lt;- c // 取走c的数据！
&lt;-quit
</code></pre></li>
<li><p>设置缓冲信道,这样信道就可以保存数据了，可以保存的数据长度为信道的长度，并且只有在存储的数据要超出信道的长度的时候，才会挂起，等待第一个数据被其他的goroutine拿走。</p>

<pre><code>func test() {
          ch := make(chan int, 3)
  ch &lt;- 1
  ch &lt;- 2
  ch &lt;- 3
  for v := range ch {
      fmt.Println(v)
  if len(ch) &lt;= 0 {
  break
  }
  }
      }
</code></pre>

<ol>
<li>上述就是设置了一个缓冲的信道，长度为3，最大能够录入3个，如果大于3个会阻塞，等待有channel被消费。</li>
<li><p>缓冲的信道是能够用range来遍历的，但是由于range不等到信道关闭是不会结束读取的，所以即使是ch长度为0，range也是会<br/>
继续去取，所以会报死锁的错误，所以通过判断ch的长度决定退出。(注意，这个如果是在信道存取的时候进行长度判断会出问题的。最好的方法是显示的关闭信道,<br/>
信道关闭之后，信道是只读的，不能写。)</p>

<pre><code>func test() {
        ch := make(chan int, 4)
        ch &lt;- 1
        ch &lt;- 2
        ch &lt;- 3
        close(ch)
        //ch &lt;- 4 //
            for v := range ch {
        fmt.Println(v)

        }
     }
</code></pre></li>
</ol></li>
</ol></li>
<li><p>并发 OR 并行</p>

<ol>
<li>并发区别于并行： 并发的意思是多个goroutine轮流的使用单核CPU，并行是每个goroutine都可以在另外单独的CPU上单独的运行。</li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 反射问题]]></title>
    <link href="http://blog.izgnod.com/14727911561394.html"/>
    <updated>2016-09-02T12:39:16+08:00</updated>
    <id>http://blog.izgnod.com/14727911561394.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>指针的反射</p>

<pre><code>func test6() {
        type User struct {
            Username string
        }
        type Admin struct {
            User
            title string
        }
        u := new(Admin)
        t := reflect.TypeOf(u)
        if t.Kind() == reflect.Ptr {
            t = t.Elem()
        }
}
</code></pre></li>
<li><p>结构体的反射</p>

<pre><code>// 反射结构体内容
func test5() {
        type User struct {
                Username string
        }
        type Admin struct {
                User
                title string
       }
       func() {
                var u Admin
                t := reflect.TypeOf(u)
                for i, n := 0, t.NumField(); i &lt; n; i++ {
                    f := t.Field(i)
                    fmt.Println(f.Name, f.Type)
                }
       }()
  }
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 指针问题]]></title>
    <link href="http://blog.izgnod.com/14727906220786.html"/>
    <updated>2016-09-02T12:30:22+08:00</updated>
    <id>http://blog.izgnod.com/14727906220786.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang指针<br><br/>
<strong>除了正常的指针之外，还有以下两种指针，一种是unsafe.Pointer指针，把任何的指针看成一个正常的指针，uintptr是将任何的一个指针都看成一个整数。</strong></p>

<ol>
<li><p>unsafe.Pointer指针</p>

<pre><code>// unsafe.Pointer 指针
    func test4() {
        type data struct {
            x [1024 * 100]byte
        }

        tmp := func() unsafe.Pointer {
             p := &amp;data{}
             return unsafe.Pointer(p)
        }

        const N = 10000
        cache := new([N]unsafe.Pointer)
        for i := 0; i &lt; N; i++ {
             cache[i] = tmp()
             time.Sleep(time.Millisecond)
        }
 }
</code></pre></li>
<li><p>uintptr指针(将指针看成一个整数)</p>

<pre><code>// uintptr 指针
func test3() {
    type data struct {
                x [1024 * 100]byte
    }

    tmp := func() uintptr {
            p := &amp;data{}
            return uintptr(unsafe.Pointer(p))
    }

    const N = 10000
    cache := new([N]uintptr)
    fmt.Println(reflect.TypeOf(cache))
    for i := 0; i &lt; N; i++ {
                cache[i] = tmp()
                time.Sleep(time.Millisecond)
        }
} 
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术类博客收集]]></title>
    <link href="http://blog.izgnod.com/14727777201831.html"/>
    <updated>2016-09-02T08:55:20+08:00</updated>
    <id>http://blog.izgnod.com/14727777201831.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">精华网站</h2>

<ol>
<li><a href="http://blog.jobbole.com/">伯乐在线</a>
主要是一些原创的聚合站点</li>
<li><a href="http://www.importnew.com/">ImportNew</a>
Java &amp; Android 技术分享</li>
<li><a href="http://segmentfault.com/">Segmentfault</a>
年轻开发者社区；最前沿的技术问答，最纯粹的技术切磋</li>
<li><a href="http://www.infoq.com/cn/">InfoQ</a>
InfoQ - 促进软件开发领域知识与创新的传播</li>
<li><a href="http://www.v2ex.com/">V2EX</a>
V2EX 是创意工作者们的社区。这里目前汇聚了超过 75000 名主要来自互联网行业、游戏行业和媒体行业的创意工作</li>
</ol>

<h2 id="toc_1">互联网公司团队博客</h2>

<ol>
<li><a href="http://www.jianshu.com/p/ca676b17603e">腾讯全端 AlloyTeam 团队 Blog</a>
Tencent  前端</li>
<li><a href="http://blogs.360.cn/">奇虎360技术博客</a></li>
<li><a href="http://tech.meituan.com/">美团技术团队</a></li>
<li><a href="http://tech.uc.cn/">UC技术博客</a></li>
<li><a href="http://www.jianshu.com/p/ca676b17603e">Tecent CDC</a></li>
</ol>

<h2 id="toc_2">业界大牛博客推荐</h2>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://coolshell.cn/">酷 壳</a></li>
<li><a href="http://it.deepinmind.com/">Java 译站</a></li>
<li><a href="http://www.aips.me/">周良的博客</a></li>
<li><a href="http://www.itzhai.com/">IT 宅</a></li>
<li><a href="http://macshuo.com/">MacTalk-池建强的随想录</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://yes2.me/">钟超&quot;s Blogs</a></li>
<li><a href="http://mindhacks.cn/">刘未鹏 | MIND HACKS</a></li>
<li><a href="http://www.raychase.net/">四火的唠叨</a></li>
<li><a href="http://blog.codingnow.com/">云风的 BLOG</a></li>
<li><a href="http://dbanotes.net/">Fenng</a></li>
<li><a href="http://beyondvincent.com/">破船之家</a></li>
<li><a href="http://blog.zhaojie.me/">老赵点滴 - 追求编程之美</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://bluedavy.me/">BlueDavy之技术Blog</a></li>
<li><a href="http://ifeve.com/">并发编程网</a></li>
<li><a href="http://timyang.net/">Tim&#39;s blog</a></li>
</ol>

<h2 id="toc_3">外部链接：</h2>

<ol>
<li><a href="http://blogwall.us/">博客墙</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[容器脚本]]></title>
    <link href="http://blog.izgnod.com/14726120122280.html"/>
    <updated>2016-08-31T10:53:32+08:00</updated>
    <id>http://blog.izgnod.com/14726120122280.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">容器清理脚本</h3>

<pre><code>#!/bin/sh

&gt;/tmp/run_image_ids.$$

DOCKER_BIN=/usr/bin/docker
LOG=/var/log/docker-cleanup.log

rm /tmp/run_image_ids.$$

echo &quot;$(date) start-----&quot; &gt;&gt;$LOG

$DOCKER_BIN ps --no-trunc -a -q | while read cid
do
  running=$($DOCKER_BIN inspect -f &#39;{{.State.Running}}&#39; $cid )
  if [ &quot;$running&quot;x = &quot;true&quot;x ]
  then
    id=$($DOCKER_BIN inspect -f &#39;{{.Image}}&#39; $cid )
    echo $id &gt;&gt;/tmp/run_image_ids.$$
    continue
  fi 
  fini=$($DOCKER_BIN inspect -f &#39;{{.State.FinishedAt}}&#39; $cid | awk -F. &#39;{print $1}&#39;)
  diff=$(expr $(date +&quot;%s&quot;) - $(date --date=&quot;$fini&quot; +&quot;%s&quot;))    
  #for MacOs 
  #diff=$(expr $(date +&quot;%s&quot;) - $(date -j -f %Y-%m-%dT%H:%M:%S &quot;$fini&quot; +&quot;%s&quot;))
  if [ $diff -gt 86400 ]
  then
     $DOCKER_BIN rm -v $cid &gt;&gt;$LOG 2&gt;&amp;1
  fi 
done


$DOCKER_BIN images --no-trunc | grep -v REPOSITORY | while read line
do
  repo_tag=$(echo $line | awk &#39;{print $1&quot;:&quot;$2}&#39;)
  image_id=$(echo $line | awk &#39;{print $3}&#39;)
  grep -q $image_id /tmp/run_image_ids.$$
  if [ $? -eq 0 ]
  then
    continue
  fi
  if [ &quot;$repo_tag&quot;x = &quot;&lt;none&gt;:&lt;none&gt;&quot;x ]
  then
    $DOCKER_BIN rmi $image_id &gt;&gt;$LOG 2&gt;&amp;1
  else
    $DOCKER_BIN rmi $repo_tag &gt;&gt;$LOG 2&gt;&amp;1
  fi
done

rm /tmp/run_image_ids.$$


echo &quot;$(date) end-----&quot; &gt;&gt;$LOG
</code></pre>

<p><strong>清理内容</strong><br/>
    1. 停止超过一天的容器<br/>
    2. 一天之内没有运行过容器的镜像</p>

]]></content>
  </entry>
  
</feed>
