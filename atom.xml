<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[重剑无锋，大巧不工。]]></title>
  <link href="http://blog.izgnod.com/atom.xml" rel="self"/>
  <link href="http://blog.izgnod.com/"/>
  <updated>2016-09-11T21:35:10+08:00</updated>
  <id>http://blog.izgnod.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Postgresql]]></title>
    <link href="http://blog.izgnod.com/14742795357312.html"/>
    <updated>2016-09-19T18:05:35+08:00</updated>
    <id>http://blog.izgnod.com/14742795357312.html</id>
    <content type="html"><![CDATA[
<ol>
<li>测试用例：</li>
</ol>

<pre><code>
    CREATE TABLE users (
    id uuid primary key default gen_random_uuid(),
    mobile text UNIQUE not null
    );
    INSERT INTO users (mobile) VALUES (&#39;86-1000000000&#39;)

</code></pre>

<ol>
<li>全在代码里：</li>
</ol>

<pre><code>package main

import (
    &quot;database/sql&quot;
    &quot;log&quot;

    //&quot;fmt&quot;
    &quot;fmt&quot;
    _ &quot;github.com/lib/pq&quot;
    &quot;time&quot;
    &quot;github.com/lib/pq&quot;
)

func main() {

    // 数据库连接
    db, err := sql.Open(&quot;postgres&quot;, &quot;user=postgres dbname=meidb sslmode=disable&quot;)
    if err != nil {
        log.Fatal(err)
    }

    // 连接数
    db.SetMaxOpenConns(10) // 最大连接数
    db.SetMaxIdleConns(5)  // 最大空闲数

    for i := 0; i &lt; 10; i++ {
        go func() {
            db.Ping()
        }()
    }
    //time.Sleep(10 * time.Second)

    // Exec 执行一次，没有具体值返回
    a, err := HowToExec(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Exec Result:&quot;, a)

    // Prepare
    for i := 0; i &lt; 10; i++ {
        go func() {
            p, err := HowToPrepare(db)
            if err != nil {
                log.Fatal(err)
            }
            fmt.Println(&quot;Prepare Result:&quot;, p)
        }()
    }
    time.Sleep(20 * time.Second)

    // QueryRow
    result, err := HowToQueryRow(db)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;QueryRow Result:&quot;, result)

    // Query
    total, results := HowToQuery(db)
    fmt.Println(&quot;Query Result:&quot;, total, results)


    // Begin
    HowToBegin(db)

    // 关闭连接
    defer db.Close()

}

func HowToExec(db *sql.DB) (int64, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;UPDATE users SET mobile=$1 WHERE mobile=$1;&quot;
    ret, err := db.Exec(q, m)
    if err != nil {
        return 0, err
    }
    r, err := ret.RowsAffected()
    ret.LastInsertId()
    if err != nil {
        return 0, err
    }
    return r, nil
}

func HowToPrepare(db *sql.DB) ([]string, error) {
    m := &quot;86-1000000000&quot;
    q := &quot;SELECT id FROM users WHERE mobile=$1&quot;
    sm, err := db.Prepare(q)
    defer sm.Close()
    if err != nil {
        return []string{}, err
    }
    exec, err := sm.Exec(m)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    ret, err := exec.RowsAffected()
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare Exec Result:&quot;, ret)

    var queryTemp string
    query := sm.QueryRow(m)
    err = query.Scan(&amp;queryTemp)
    if err != nil {
        log.Println(err)
        return []string{}, nil
    }
    fmt.Println(&quot;Prepare QueryRow Result:&quot;, queryTemp)

    sq, err := sm.Query(m)
    defer sq.Close()
    var re []string
    for sq.Next() {
        var tmp string
        err := sq.Scan(&amp;tmp)
        if err != nil {
            log.Println(err)
            return []string{}, nil
        }
        re = append(re, tmp)
    }
    fmt.Println(&quot;Prepare Query Result:&quot;, re)

    return re, nil
}

func HowToQueryRow(db *sql.DB) (string, error) {
    m := &quot;86-1000000000&quot;
    var temp string
    row := db.QueryRow(&quot;SELECT id FROM users WHERE mobile=$1&quot;, m)
    err := row.Scan(&amp;temp)
    if err != nil {
        if err == sql.ErrNoRows {
            // 没有查询到结果的返回,可以进行日志输出
            return temp, nil
        }
        // 出错，但是不是查询结果的问题
        return temp, err
    }
    return temp, nil
}

func HowToQuery(db *sql.DB) (total int, result []string) {
    q := &quot;SELECT id FROM users WHERE mobile=$1 ORDER BY id DESC OFFSET $2 LIMIT $3;&quot;
    qa := &quot;SELECT count(*) FROM users WHERE mobile=$1;&quot;
    m := &quot;86-1000000000&quot;
    var temp string

    // 查询总数
    row := db.QueryRow(qa, m)
    err := row.Scan(&amp;total)
    if err != nil {
        if err == sql.ErrNoRows {
            return 0, []string{}
        }
        log.Fatal(err)
    }

    // 结果查询
    rows, err := db.Query(q, m, 0, 20)
    defer rows.Close() // 将query关闭之后才能将连接放回连接池
    if err != nil {
        log.Fatal(err)
    }
    // 依次的准备好每一条查出的数据
    for rows.Next() {
        err := rows.Scan(&amp;temp)
        if err != nil {
            log.Fatal(err)

        }
        result = append(result, temp)
    }
    return total, result
}

func HowToBegin(db *sql.DB) {
    m := &quot;86-1000000001&quot;
    cm := &quot;86-1000000002&quot;
    txn, err := db.Begin()
    if err != nil {
        log.Println(err)
        return
    }

    stmt, err := txn.Prepare(pq.CopyIn(&quot;users&quot;, &quot;mobile&quot;))
    defer stmt.Close()

    if err != nil {
        log.Println(err)
        return
    }
    for i := 0; i &lt; 10; i++{
        _ , err :=stmt.Exec(m)
        if err != nil{
            log.Println(err)
            return
        }
    }

    _, err = stmt.Exec()
    if err != nil {
        log.Println(err)
        return
    }
    _, err = txn.Exec(&quot;UPDATE users SET mobile=$1&quot;,cm)
    if err != nil {
        log.Println(err)
        return
    }
    var id string
    var mob string
    err = txn.QueryRow(&quot;SELECT id, mobile FROM users WHERE mobile=$1&quot;, cm).Scan(&amp;id, &amp;mob)
    if err != nil {
        log.Println(err)
        return
    }
    fmt.Println(id, mob)

    // 事物提交
    err = txn.Commit()
    if err!= nil {
        log.Fatal()
    }

    //回滚
    //err = txn.Rollback()
    //if err!= nil {
    //  log.Fatal()
    //}

}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curl Http 测试]]></title>
    <link href="http://blog.izgnod.com/14742597754498.html"/>
    <updated>2016-09-19T12:36:15+08:00</updated>
    <id>http://blog.izgnod.com/14742597754498.html</id>
    <content type="html"><![CDATA[
<ol>
<li>常用参数</li>
</ol>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-X —request [GET POST PUT DELETE]</td>
<td>指定方法</td>
</tr>
<tr>
<td>-H —header</td>
<td>设定header</td>
</tr>
<tr>
<td>-i —include</td>
<td>显示response 中的header</td>
</tr>
<tr>
<td>-d —data</td>
<td>http的parameters</td>
</tr>
<tr>
<td>-v —verbose</td>
<td>输出详情</td>
</tr>
<tr>
<td>-u —user</td>
<td>使用者的账号，密码</td>
</tr>
<tr>
<td>-b —cookie</td>
<td>cookie</td>
</tr>
</tbody>
</table>

<p>用例：</p>

<pre><code>curl -X GET &quot;http://www.baidu.com/&quot;
curl -X POST &quot;http://www.baidu.com/&quot;
curl -X PUT &quot;http://www.baidu.com/&quot;
curl -X DELETE &quot;http://www.baidu.com/&quot;
</code></pre>

<ol>
<li><p>HEADER 信息<br/>
例如：（多个header对应多个-H参数）</p>

<pre><code>curl -v -i -H &quot;Content-Type: application/json&quot; &quot;http://www.baidu.com/&quot;
</code></pre></li>
<li><p>http 参数</p>

<ol>
<li>request parameter
例如：</li>
</ol>

<pre><code>    # 使用`&amp;`串接多个参数
    curl -X POST -d &quot;param1=value1&amp;param2=value2&quot;
    # 也可使用多個`-d`，效果同上
    curl -X POST -d &quot;param1=value1&quot; -d &quot;param2=value2&quot;
    curl -X POST -d &quot;param1=a 0space&quot;     
    # &quot;a space&quot; url encode後空白字元會編碼成&#39;%20&#39;為&quot;a%20space&quot;，編碼後的參數可以直接使用
    curl -X POST -d &quot;param1=a%20space&quot;     
</code></pre>

<ol>
<li>request json
例如：</li>
</ol>

<pre><code>    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -H &quot;Accept:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
    # 不加&quot;Accept:application/json&quot;也可以
    curl http://www.example.com?modifier=kent -X PUT -i -H &quot;Content-Type:application/json&quot; -d &#39;{&quot;boolean&quot; : false, &quot;foo&quot; : &quot;bar&quot;}&#39;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 参数]]></title>
    <link href="http://blog.izgnod.com/14741728889918.html"/>
    <updated>2016-09-18T12:28:08+08:00</updated>
    <id>http://blog.izgnod.com/14741728889918.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">入参类型</h2>

<ul>
<li>如果是map，func，chan则不需要用指针，本身就是引用类型</li>
<li>如果是slice，方法中不需要修改，则不需要用指针</li>
<li>如果是func， 也需要方法内部替换的，就使用指针</li>
<li>如果是包含sysnc.Mutex的struct，则需要传指针，避免对象的复制</li>
<li>如果是大的array，struct，传指针比较好，如何评判是否够大，例如：比方法的对象还大。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书]]></title>
    <link href="http://blog.izgnod.com/14734878748126.html"/>
    <updated>2016-09-10T14:11:14+08:00</updated>
    <id>http://blog.izgnod.com/14734878748126.html</id>
    <content type="html"><![CDATA[
<ol>
<li><a href="https://link.zhihu.com/?target=http%3A//www.quzhuanpan.com/source/search.action%3Fq%3Dkindle%2520%25E7%2594%25B5%25E5%25AD%2590%25E4%25B9%25A6%26currentPage%3D1">百度云资源搜索</a></li>
<li><a href="https://www.jiumodiary.com/">Jiumo E-Book Search 鸠摩搜书</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//readcolor.com">读远：发掘优质电子书资源，提供好书分享、下载与推送。支持mobi/epub/pdf/txt格式。</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//gen.lib.rus.ec">Library genesis 英文科学著作</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.gutenberg.org">Gutenberg 维基古腾堡计划</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Sort排序]]></title>
    <link href="http://blog.izgnod.com/14730511199413.html"/>
    <updated>2016-09-05T12:51:59+08:00</updated>
    <id>http://blog.izgnod.com/14730511199413.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang Sort 使用方法：</p>

<ol>
<li><p>实现Sort Interface 的三个方法</p>

<pre><code>Len()
Less(i, j int) bool
Swap(i, j int) 
</code></pre>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

//学生成绩结构体
type StuScore struct {
    //姓名
    name  string
    //成绩
    score int
}

type StuScores []StuScore

//Len()
func (s StuScores) Len() int {
    return len(s)
}

//Less():成绩将有低到高排序
func (s StuScores) Less(i, j int) bool {
    return s[i].score  &lt; s[j].score
}

//Swap()
func (s StuScores) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

func main() {
    stus := StuScores{
        {&quot;alan&quot;, 95},
        {&quot;hikerell&quot;, 91},
        {&quot;acmfly&quot;, 96},
        {&quot;leao&quot;, 90}}

    fmt.Println(&quot;Default:&quot;)
    //原始顺序
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }
    fmt.Println()
    //StuScores已经实现了sort.Interface接口
    sort.Sort(stus)

    fmt.Println(&quot;Sorted:&quot;)
    //排好序后的结构
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
    }

    //判断是否已经排好顺序，将会打印true
    fmt.Println(&quot;IS Sorted?&quot;, sort.IsSorted(stus))

    fmt.Println()
    // 排序翻转
    sort.Sort(sort.Reverse(stus))
    for _, v := range stus {
        fmt.Println(v.name, &quot;:&quot;, v.score)
        }
    }
</code></pre></li>
</ol></li>
<li><p>内部数据类型排序</p>

<ol>
<li><p>IntSlice, Float64Slice, StringSlice<br/>
举例：</p>

<pre><code>```
// 升序
s := []int{5,3,6,7,4}
sort.Ints(s)
fmt.Println(s) //将会输出[3 4 5 6 7]

// 降序
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Sort(sort.Reverse(sort.IntSlice(s)))
fmt.Println(s) //将会输出[6 5 4 3 2 1]

// 查找排序之后大于等于指定数字的位置
s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据
sort.Ints(s) //排序后的s为[1 2 3 4 5 6]
fmt.Println(sort.SearchInts(s, 3)) //将会输出2
```
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Label妙用]]></title>
    <link href="http://blog.izgnod.com/14729947807865.html"/>
    <updated>2016-09-04T21:13:00+08:00</updated>
    <id>http://blog.izgnod.com/14729947807865.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Label 使用</p>

<ol>
<li>Label 只能与 goto break continue 共同使用</li>
<li><p>使用限制：</p>

<ol>
<li><table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>效果</th>
</tr>
</thead>

<tbody>
<tr>
<td>goto</td>
<td>没有任何使用限制</td>
<td>跳转到任何地方</td>
</tr>
<tr>
<td>break </td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>终止循环，不再进入循环</td>
</tr>
<tr>
<td>continue</td>
<td>label只能在循环(for switch)紧挨的上方</td>
<td>暂停本轮循环</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>例如：</p>

<pre><code>func main() {
a := 1
LABEL1:

println(&quot;LABEL1&quot;)
println(&quot;inc a=&quot;, a)
a += 1

LABEL2:
 println(&quot;LABEL1&quot;) // 会报错的

for a &lt; 6 {
println(a)
if a == 3 {
a += 1
continue LABEL2
}
if a == 5 {
break
}
goto LABEL1
}

}
</code></pre></li>
<li><p>经典用法:<br/>
平常的循环嵌套：</p>

<pre><code>for _, item := range list.Items {
found := false

for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
found = true
break
}
... do some other work ...
}

if found {
continue
}

... do some other work ...
}
</code></pre>

<p>使用label的嵌套:</p>

<pre><code>OUTER:
for _, item := range list.Items {
for _, reserved := range reserved.Items {
if reserved.ID == item.ID {
    continue OUTER
}
... do some other work ...
}
... do some other work ...
}
</code></pre>

<p><strong>Label放在for循环之前是表明跳出到哪一层的循环，不会影响到for循环，并不是每次跳跃之后都要重新执行for循环</strong></p></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法]]></title>
    <link href="http://blog.izgnod.com/14728851727641.html"/>
    <updated>2016-09-03T14:46:12+08:00</updated>
    <id>http://blog.izgnod.com/14728851727641.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>今天看golang源码关于字符串的时候发现strings.Replace方法使用的是Boyer-Moore算法</p>

<ol>
<li>推荐两个博文：

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">阮一峰字符串匹配的Boyer-Moore算法</a> </li>
<li><a href="http://www.cs.utexas.edu/%7Emoore/best-ideas/string-searching/index.html">Moore教授自己给出的例子</a></li>
</ol></li>
</ol></li>
<li><p>具体的实现：</p>

<ol>
<li>golang Strings 包中有实现</li>
<li><a href="https://github.com/ijibu/gobm">https://github.com/ijibu/gobm</a> 这个也是模仿strings包中的实现<br/></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 并发问题]]></title>
    <link href="http://blog.izgnod.com/14727913418128.html"/>
    <updated>2016-09-02T12:42:21+08:00</updated>
    <id>http://blog.izgnod.com/14727913418128.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>go关键字带来的并发</p>

<pre><code>func loop() {
// fmt.Println(&quot;wood&quot;)
    for i := 0; i &lt; 10; i++ {
    fmt.Printf(&quot;%d&quot;, i)
    }
}
func test() {
    loop()
    go loop()
    time.Sleep(time.Second)// 如果不等待，test会在goruntine没有开始执行就已经退出了。
}
</code></pre></li>
<li><p>信道带来的goroutine通信</p>

<ol>
<li><p>无缓存信道</p>

<pre><code>func test1() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
    messages &lt;- &quot;step 1&quot;
    }()
    fmt.Println(&quot;step 2&quot;)
    time.Sleep(time.Second)
}
</code></pre>

<p>注意：</p>

<ol>
<li><p>这种情况信道中放入东西，但是没有人取,能够正常退出。</p>

<pre><code>➜  src git:(master) ✗ go run hello.go
     go run hello.go
     step 1
     step 2
</code></pre></li>
<li><p>这种情况信道没有人放东西，但是有取得操作。所以会发生死锁。</p>

<pre><code>func test4() {
    go func() {
    fmt.Println(&quot;step 1&quot;)
}()
&lt;-messages
}
</code></pre>

<pre><code>➜  src git:(master) ✗ go run hello.go
go run hello.go
step 1
fatal error: all goroutines are asleep - deadlock!
</code></pre></li>
<li><p>通过设置标志位控制执行顺序</p>

<pre><code> func test6() {
       complete := make(chan int)
         go func() {
        for i := 0; i &lt; 10; i++ {
               fmt.Printf(&quot;%d&quot;, i)

       }
       complete &lt;- 0

    }()
    fmt.Println(&quot;step 1&quot;)
    &lt;-complete
    fmt.Println(&quot;step 2&quot;)
}
</code></pre>

<p><strong>总结：也就是说，无缓存的信道，在存和取得时候都会临时挂起自己的goroutine,等到另外一端准备好之后才够恢复。<br/>
无缓冲的信道永远不会存储数据，只是负责数据的流通，所以数据要流转起来。</strong></p></li>
</ol></li>
</ol></li>
<li><p>channel 类型问题<br/>
channel的几种类型：chan type , chan&lt;- type , &lt;-chan type</p>

<ol>
<li><p>chan type 这种类型是可读又可以写的</p>

<pre><code>    package main
    import &quot;fmt&quot;

    func main() {
    test := []int{1, 2, 3}
    good := gen(test...)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    fmt.Println(&lt;-good)
    go func() {
    good &lt;- 4 // 这个地方必须是routine才可以向good中写入，如果good 类型是&lt;-chan int 是可以写入的，如果是chan&lt;- int只可以写入
    }()
    fmt.Println(&lt;-good)
    }

    func gen(nums ...int) chan int { //&lt;-chan int 只能读，chan&lt;- int 只能写
    out := make(chan int) // 没有缓存的chan，长度为1
    go func() {
    for _, n := range nums {
    out &lt;- n
    }
    // close(out) // 关闭之后则不能写入
    }()
    return out
    }
</code></pre></li>
</ol></li>
<li><p>死锁: 线程或者进程在等待资源的时候，一直无法得到所需要的就会陷入一种状态，这种状态就叫做死锁。</p>

<ol>
<li><p>死锁的几种情况</p>

<ol>
<li><p>在单独的gorunitine中操作无缓冲的信道，一定发生死锁。</p>

<pre><code>func main() {
    ch := make(chan int)
     ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开
    fmt.Println(&quot;This line code wont run&quot;) //在此行执行之前Go就会报死锁
}
</code></pre></li>
<li><p>多个无缓冲的信道相互依赖，可能会发生死锁。</p>

<pre><code>func test7() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        fmt.Println(&quot;wonder&quot;)
        ch1 &lt;- &lt;-ch2
    }()
    &lt;-ch1
}
</code></pre></li>
<li><p>多个无缓冲的信道，部分信道数据不能流动</p>

<pre><code> c, quit := make(chan int), make(chan int)
 go func() {
 c &lt;- 1  // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine
 quit &lt;- 0 // quit始终没有办法写入数据
 }()
 &lt;- quit // quit 等待数据的写
</code></pre></li>
</ol></li>
<li><p>解决死锁的方法：</p>

<ol>
<li><p>把没有放入的数据，赶紧放入，把没有取走的数据，赶紧取走。 </p>

<pre><code>c, quit := make(chan int), make(chan int)
go func() {
      c &lt;- 1
  quit &lt;- 0
}()
&lt;- c // 取走c的数据！
&lt;-quit
</code></pre></li>
<li><p>设置缓冲信道,这样信道就可以保存数据了，可以保存的数据长度为信道的长度，并且只有在存储的数据要超出信道的长度的时候，才会挂起，等待第一个数据被其他的goroutine拿走。</p>

<pre><code>func test() {
          ch := make(chan int, 3)
  ch &lt;- 1
  ch &lt;- 2
  ch &lt;- 3
  for v := range ch {
      fmt.Println(v)
  if len(ch) &lt;= 0 {
  break
  }
  }
      }
</code></pre>

<ol>
<li>上述就是设置了一个缓冲的信道，长度为3，最大能够录入3个，如果大于3个会阻塞，等待有channel被消费。</li>
<li><p>缓冲的信道是能够用range来遍历的，但是由于range不等到信道关闭是不会结束读取的，所以即使是ch长度为0，range也是会<br/>
继续去取，所以会报死锁的错误，所以通过判断ch的长度决定退出。(注意，这个如果是在信道存取的时候进行长度判断会出问题的。最好的方法是显示的关闭信道,<br/>
信道关闭之后，信道是只读的，不能写。)</p>

<pre><code>func test() {
        ch := make(chan int, 4)
        ch &lt;- 1
        ch &lt;- 2
        ch &lt;- 3
        close(ch)
        //ch &lt;- 4 //
            for v := range ch {
        fmt.Println(v)

        }
     }
</code></pre></li>
</ol></li>
</ol></li>
<li><p>并发 OR 并行</p>

<ol>
<li>并发区别于并行： 并发的意思是多个goroutine轮流的使用单核CPU，并行是每个goroutine都可以在另外单独的CPU上单独的运行。</li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 反射问题]]></title>
    <link href="http://blog.izgnod.com/14727911561394.html"/>
    <updated>2016-09-02T12:39:16+08:00</updated>
    <id>http://blog.izgnod.com/14727911561394.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>指针的反射</p>

<pre><code>func test6() {
        type User struct {
            Username string
        }
        type Admin struct {
            User
            title string
        }
        u := new(Admin)
        t := reflect.TypeOf(u)
        if t.Kind() == reflect.Ptr {
            t = t.Elem()
        }
}
</code></pre></li>
<li><p>结构体的反射</p>

<pre><code>// 反射结构体内容
func test5() {
        type User struct {
                Username string
        }
        type Admin struct {
                User
                title string
       }
       func() {
                var u Admin
                t := reflect.TypeOf(u)
                for i, n := 0, t.NumField(); i &lt; n; i++ {
                    f := t.Field(i)
                    fmt.Println(f.Name, f.Type)
                }
       }()
  }
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 指针问题]]></title>
    <link href="http://blog.izgnod.com/14727906220786.html"/>
    <updated>2016-09-02T12:30:22+08:00</updated>
    <id>http://blog.izgnod.com/14727906220786.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>Golang指针<br><br/>
<strong>除了正常的指针之外，还有以下两种指针，一种是unsafe.Pointer指针，把任何的指针看成一个正常的指针，uintptr是将任何的一个指针都看成一个整数。</strong></p>

<ol>
<li><p>unsafe.Pointer指针</p>

<pre><code>// unsafe.Pointer 指针
    func test4() {
        type data struct {
            x [1024 * 100]byte
        }

        tmp := func() unsafe.Pointer {
             p := &amp;data{}
             return unsafe.Pointer(p)
        }

        const N = 10000
        cache := new([N]unsafe.Pointer)
        for i := 0; i &lt; N; i++ {
             cache[i] = tmp()
             time.Sleep(time.Millisecond)
        }
 }
</code></pre></li>
<li><p>uintptr指针(将指针看成一个整数)</p>

<pre><code>// uintptr 指针
func test3() {
    type data struct {
                x [1024 * 100]byte
    }

    tmp := func() uintptr {
            p := &amp;data{}
            return uintptr(unsafe.Pointer(p))
    }

    const N = 10000
    cache := new([N]uintptr)
    fmt.Println(reflect.TypeOf(cache))
    for i := 0; i &lt; N; i++ {
                cache[i] = tmp()
                time.Sleep(time.Millisecond)
        }
} 
</code></pre></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术类博客收集]]></title>
    <link href="http://blog.izgnod.com/14727777201831.html"/>
    <updated>2016-09-02T08:55:20+08:00</updated>
    <id>http://blog.izgnod.com/14727777201831.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">精华网站</h2>

<ol>
<li><a href="http://blog.jobbole.com/">伯乐在线</a>
主要是一些原创的聚合站点</li>
<li><a href="http://www.importnew.com/">ImportNew</a>
Java &amp; Android 技术分享</li>
<li><a href="http://segmentfault.com/">Segmentfault</a>
年轻开发者社区；最前沿的技术问答，最纯粹的技术切磋</li>
<li><a href="http://www.infoq.com/cn/">InfoQ</a>
InfoQ - 促进软件开发领域知识与创新的传播</li>
<li><a href="http://www.v2ex.com/">V2EX</a>
V2EX 是创意工作者们的社区。这里目前汇聚了超过 75000 名主要来自互联网行业、游戏行业和媒体行业的创意工作</li>
</ol>

<h2 id="toc_1">互联网公司团队博客</h2>

<ol>
<li><a href="http://www.jianshu.com/p/ca676b17603e">腾讯全端 AlloyTeam 团队 Blog</a>
Tencent  前端</li>
<li><a href="http://blogs.360.cn/">奇虎360技术博客</a></li>
<li><a href="http://tech.meituan.com/">美团技术团队</a></li>
<li><a href="http://tech.uc.cn/">UC技术博客</a></li>
<li><a href="http://www.jianshu.com/p/ca676b17603e">Tecent CDC</a></li>
</ol>

<h2 id="toc_2">业界大牛博客推荐</h2>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://coolshell.cn/">酷 壳</a></li>
<li><a href="http://it.deepinmind.com/">Java 译站</a></li>
<li><a href="http://www.aips.me/">周良的博客</a></li>
<li><a href="http://www.itzhai.com/">IT 宅</a></li>
<li><a href="http://macshuo.com/">MacTalk-池建强的随想录</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://yes2.me/">钟超&quot;s Blogs</a></li>
<li><a href="http://mindhacks.cn/">刘未鹏 | MIND HACKS</a></li>
<li><a href="http://www.raychase.net/">四火的唠叨</a></li>
<li><a href="http://blog.codingnow.com/">云风的 BLOG</a></li>
<li><a href="http://dbanotes.net/">Fenng</a></li>
<li><a href="http://beyondvincent.com/">破船之家</a></li>
<li><a href="http://blog.zhaojie.me/">老赵点滴 - 追求编程之美</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://bluedavy.me/">BlueDavy之技术Blog</a></li>
<li><a href="http://ifeve.com/">并发编程网</a></li>
<li><a href="http://timyang.net/">Tim&#39;s blog</a></li>
</ol>

<h2 id="toc_3">外部链接：</h2>

<ol>
<li><a href="http://blogwall.us/">博客墙</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[容器脚本]]></title>
    <link href="http://blog.izgnod.com/14726120122280.html"/>
    <updated>2016-08-31T10:53:32+08:00</updated>
    <id>http://blog.izgnod.com/14726120122280.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">容器清理脚本</h3>

<pre><code>#!/bin/sh

&gt;/tmp/run_image_ids.$$

DOCKER_BIN=/usr/bin/docker
LOG=/var/log/docker-cleanup.log

rm /tmp/run_image_ids.$$

echo &quot;$(date) start-----&quot; &gt;&gt;$LOG

$DOCKER_BIN ps --no-trunc -a -q | while read cid
do
  running=$($DOCKER_BIN inspect -f &#39;{{.State.Running}}&#39; $cid )
  if [ &quot;$running&quot;x = &quot;true&quot;x ]
  then
    id=$($DOCKER_BIN inspect -f &#39;{{.Image}}&#39; $cid )
    echo $id &gt;&gt;/tmp/run_image_ids.$$
    continue
  fi 
  fini=$($DOCKER_BIN inspect -f &#39;{{.State.FinishedAt}}&#39; $cid | awk -F. &#39;{print $1}&#39;)
  diff=$(expr $(date +&quot;%s&quot;) - $(date --date=&quot;$fini&quot; +&quot;%s&quot;))    
  #for MacOs 
  #diff=$(expr $(date +&quot;%s&quot;) - $(date -j -f %Y-%m-%dT%H:%M:%S &quot;$fini&quot; +&quot;%s&quot;))
  if [ $diff -gt 86400 ]
  then
     $DOCKER_BIN rm -v $cid &gt;&gt;$LOG 2&gt;&amp;1
  fi 
done


$DOCKER_BIN images --no-trunc | grep -v REPOSITORY | while read line
do
  repo_tag=$(echo $line | awk &#39;{print $1&quot;:&quot;$2}&#39;)
  image_id=$(echo $line | awk &#39;{print $3}&#39;)
  grep -q $image_id /tmp/run_image_ids.$$
  if [ $? -eq 0 ]
  then
    continue
  fi
  if [ &quot;$repo_tag&quot;x = &quot;&lt;none&gt;:&lt;none&gt;&quot;x ]
  then
    $DOCKER_BIN rmi $image_id &gt;&gt;$LOG 2&gt;&amp;1
  else
    $DOCKER_BIN rmi $repo_tag &gt;&gt;$LOG 2&gt;&amp;1
  fi
done

rm /tmp/run_image_ids.$$


echo &quot;$(date) end-----&quot; &gt;&gt;$LOG
</code></pre>

<p><strong>清理内容</strong><br/>
    1. 停止超过一天的容器<br/>
    2. 一天之内没有运行过容器的镜像</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 基础类型]]></title>
    <link href="http://blog.izgnod.com/14726074871676.html"/>
    <updated>2016-08-31T09:38:07+08:00</updated>
    <id>http://blog.izgnod.com/14726074871676.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量声明</h2>

<ol>
<li><p>不同基础类型的零值</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>

<tbody>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr>
<td>struct</td>
<td>nil</td>
</tr>
<tr>
<td>array</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
</tr>
</tbody>
</table></li>
<li><p>var a int 和 a := 0 的哲学</p>

<ol>
<li><p>var a int </p>

<p>var a int 可以用来声明局部和全局变量,如果不初始化那么就是对应的零值     var a int = 1 可以声明并且初始化</p></li>
<li><p>a := 0</p>

<p>a := 0 只能用来声明局部变量，不能够声明全局变量<br/>
a := 1 声明局部变量并且初始化</p></li>
<li><p>在局部的变量中 var 等价 : ; var 可以使用零值， : 是必须显示指明初始化值</p></li>
<li><p>我的使用习惯</p>

<ol>
<li>全局变量使用 var a int = 0 显示指明初始值</li>
<li>局部变量使用 a := 0 显示指明初始值</li>
</ol></li>
</ol>

<p><strong>注意：</strong><br/>
    var a int 也可以用做 var a = 0,效果是一样的，但是这里尽量的使用显示的指定类型和初始值</p></li>
</ol>

<h2 id="toc_1">字符串拼加性能问题</h2>

<ol>
<li>字符串拼加的三种方式：

<ol>
<li>+=</li>
<li>strings.Join()</li>
<li>bytes.Buffer</li>
</ol></li>
<li><p>比较：</p>

<pre><code>package main
import (
    &quot;fmt&quot;

    &quot;strings&quot;
    &quot;time&quot;
    &quot;bytes&quot;
)

func main() {
    var buffer bytes.Buffer

    s := time.Now()
    for i :=0; i &lt;100000; i++ {
        buffer.WriteString(&quot;test is here\n&quot;)
    }
    buffer.String() // 拼接结果
    e := time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    str := &quot;&quot;
    for i :=0; i &lt;100000; i++ {
        str += &quot;test is here\n&quot;
    }
    e = time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    var sl []string
    for i :=0; i &lt;100000; i++ {
        sl = append(sl, &quot;test is here\n&quot;)
    }
    strings.Join(sl, &quot;&quot;)
    e = time.Now()
    fmt.Println(&quot;taked time is&quot;, e.Sub(s).Seconds())
}
</code></pre>

<p><strong>运行结果</strong></p>

<pre><code>taked time is  0.0039795080000000005
taked time is  13.403575973
taked time is 0.017540489
</code></pre></li>
<li><p>[]byte 和 string </p>

<ol>
<li><p>golang 中的[]byte和string可以方便的转换</p>

<ol>
<li>[]byte -&gt; string
string([]byte) -&gt; string </li>
<li>string -&gt; []byte
[]byte(string) -&gt; []byte</li>
</ol>

<p><strong>golang中[]byte和string的方法基本上是一样的</strong></p></li>
<li><p>byte和string性能问题之buffer</p>

<ol>
<li>golang 中 bytes包中有Buffer类型以及相关方法

<ol>
<li>直接声明： var buffer bytes.Buffer</li>
<li>方法成成：</li>
</ol></li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_2">数组问题</h2>

<ol>
<li><p>声明Golang数组有两种方式</p>

<pre><code>var arr1 = new([5]int)
var arr2 [5]int
</code></pre>

<ol>
<li>Golang认为数组是一种值类型，但new的时候返回的是数组的指针。</li>
<li>第一种返回的是一个指针，传递的时候是不进行内存拷贝的。</li>
<li>第二种方式返回的是数组本身，传递的时候是进行内存拷贝的。</li>
</ol>

<pre><code>package main
import (
  &quot;fmt&quot;
)
func main() {
        var arr1 = new([5]int)
        var arr2 [5]int
        fmt.Println(arr1)
        fmt.Println(arr2)
        test := arr1
        test[0] = 123
        fmt.Println(test)
        fmt.Println(arr1)
        test2 := arr2
        test2[0] = 345
        fmt.Println(test2)
        fmt.Println(arr2)
}
   $输出结果：
        &amp;[0 0 0 0 0]
        [0 0 0 0 0]
        &amp;[123 0 0 0 0]
        &amp;[123 0 0 0 0]
        [345 0 0 0 0]
        [0 0 0 0 0]
</code></pre></li>
<li><p>切片问题<br/>
推荐阅读：<a href="http://gold.xitu.io/entry/577bbccf0a2b58005730290d">深入理解 Go 语言的 slice 以及到底什么时候该用 slice</a><br/>
    <strong>切片在进行传递的时候也是指针传递</strong></p>

<pre><code>```
    package main

    import (
        &quot;fmt&quot;
    )

    func f(a []int) {
        fmt.Println(a)
        a[0] = 123
    }
    func fp(a *[3]int) {
        fmt.Println(a)
        a[0] = 456
    }

    func main() {
        var ar [3]int
        f(ar[1:2])
        fp(&amp;ar)
        fmt.Println(ar)
    }
    $输出结果：
        [0]
        [0 123 0]
        &amp;[0 123 0]
        [456 123 0]
```

**初始化数组的时候如果是不定长的数组初始化，那么这个数组也会是一个切片**

```
package main

import (
&quot;fmt&quot;
)

func test(a []int) {
a[1] = 4
}
func main() {
var arrlazy = []int{5, 6, 6, 7}
fmt.Println(arrlazy)
test(arrlazy)
fmt.Println(arrlazy)
}
$输出结果：
[5 6 6 7]
[5 4 6 7]
```
</code></pre></li>
</ol>

<p><strong>总结：除了数组本身，切片和new一个都是指针的形式，数组本身是值类型，其余两种情况得到的嗾使指针，如果想要在传递的时候不进行拷贝操作，那么两种方式，一种就是直接传指针，另外一种的直接传切片。</strong></p>

<pre><code>    1. new() 和 make() 的关系：
        1. new() 是为变量分配内存，然后就将分配好的地址的首地址返回，并且也是进行初始化
        2. make() 这个是用来直接初始化，然后将变量直接返回。
    2. 关于效率问题：
        1. 字符串的拼凑应该直接使用bytes的buffer进行操作，会快一些。
    3. 数组和切片问题：
        1. 数组一旦定义好，就固定长度即len == cap
        2. 数组想要扩容或者是缩容可以转换成切片进行使用,即先要make一个切片，然后将数组中的数据放入其中。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql语句集锦]]></title>
    <link href="http://blog.izgnod.com/14724588246571.html"/>
    <updated>2016-08-29T16:20:24+08:00</updated>
    <id>http://blog.izgnod.com/14724588246571.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>更正Jsonb中数据：</p>

<ol>
<li><img src="media/14724588246571/14724588641183.jpg" alt=""/></li>
</ol>

<p>将其中不合法的数据改成:[&quot;镭射祛斑&quot;,&quot;c10&quot;, &quot;白瓷娃娃&quot;, &quot;黄雀斑&quot;, &quot;雀斑&quot;, &quot;色斑&quot;,&quot;微整形&quot;]<br/>
语句：<br/>
其中的问题：多个字段在一个双引号中，其中是中文的逗号。</p>

<pre><code>UPDATE table_name SET tags=to_jsonb(string_to_array(jsonb_array_elements_text(tags),&#39;，&#39;)) WHERE tags!=&#39;null&#39;;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postgresql 备份与恢复]]></title>
    <link href="http://blog.izgnod.com/14724369503027.html"/>
    <updated>2016-08-29T10:15:50+08:00</updated>
    <id>http://blog.izgnod.com/14724369503027.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">备份和定时备份</h2>

<ol>
<li><p>备份命令</p>

<pre><code>pg_dump -h host_ip -p host_port -U datebase_user -d database_name -vF c -C -c -f test1.bkp test1 
-a 为只输出数据库中的数据（此处没有用）
-v 打出执行信息
-F 输出为指定的格式 c 为custom
-c dump的时候将drop database xxx 语句放入到dump的内容中
-C dump的时候将Create database xxx 语句放入到dump的内容中
-f 指定输出dump的名称
最后一个为数据库的名字
</code></pre></li>
<li><p>定时命令：</p>

<ol>
<li>脚本内容backup_db.sh(全量导出，这里导出的是自定义格式，只能够被全量恢复和部分恢复)</li>
</ol>

<pre><code>#/bin/bash
DATE=`date +&quot;%Y_%m_%d&quot;`
/usr/bin/pg_dump -U postgres -vF c -C -c -f /share/meidb_$DATE.bak meidb
## 备份到香港阿里云（这里要把key加好）
##chmod 777 /share/meidb_$DATE.bak
/usr/bin/scp -P hostPort -i /root/.ssh/id_rsa /share/meidb_$DATE.bak
root@Hostname:/backup/ &gt;&gt; /share/scp.log 2&gt;&amp;1
</code></pre></li>
</ol>

<h2 id="toc_1">如何恢复数据</h2>

<ol>
<li><p>全量数据恢复方法</p>

<ol>
<li><p>如果需要将原先的库进行删除并且重建</p>

<ol>
<li>执行命令：</li>
</ol>

<pre><code>pg_restore -h host_ip -p host_port -U postgres -d postgres -v -C  -c test1.bkp
</code></pre></li>
</ol></li>
<li><p>部分恢复的方法：</p>

<ol>
<li><p>创建恢复表的目录批量恢复方法：</p>

<ol>
<li>执行命创建恢复目录：</li>
</ol>

<pre><code>pg_restore -l test1db_2016_18_29.bkp -f table.lst
 -l, --list print summarized TOC of the archive
 -f, --file=FILENAME output file name
</code></pre>

<ol>
<li><p>修改恢复表目录：</p>

<ol>
<li><p>修改前内容例如：</p>

<pre><code>; Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
4170; 0 18551 TABLE DATA public activities postgres
4235; 0 0 SEQUENCE SET public activities_num_seq postgres
4172; 0 18564 TABLE DATA public activity_enrolls postgres
4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>将其余的注释，然后只留下需要恢复的表明即可：<br/>
    小技巧：vim替换模式:（:16,78s#<sup>4#;4#g）</sup><br/>
    修改后内容如下(例如要恢复表accounts)：</p>

<pre><code>;     Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
;4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
;4170; 0 18551 TABLE DATA public activities postgres
;4235; 0 0 SEQUENCE SET public activities_num_seq postgres
;4172; 0 18564 TABLE DATA public activity_enrolls postgres
;4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>恢复命令：</p>

<pre><code>pg_restore -U postgres -h hostname -p port -vaxd database_name -L table.lst test1
</code></pre></li>
</ol></li>
</ol></li>
<li><p>指定恢复表的方式</p>

<ol>
<li><p>恢复命令</p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account test1.bkp
</code></pre>

<p><strong>多个文件恢复</strong></p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account -t account_items  test.bkp
</code></pre></li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选股模型]]></title>
    <link href="http://blog.izgnod.com/14723863067284.html"/>
    <updated>2016-08-28T20:11:46+08:00</updated>
    <id>http://blog.izgnod.com/14723863067284.html</id>
    <content type="html"><![CDATA[
<pre><code>1. 长阳重炮
    2. 在低位温和放量之后出现了一根带量长阳（或涨停），同时成交量为上叉阳量托，马上直扑追涨。


    3. 量五日线2北，大阳线，实体的上沿可以做多，止损放到下沿
2. 吞并翻转
    3. 第一个交易日长阴（跌停）， 第二个交易日涨停，包容第一个交易日长阴。可以在第二个交易日涨停的刹那追涨买入
3. 螺旋桨
    4. 均线多头排列： 10日线在5日线以上至少
    5. 影线长度8%
    6. 量站上5日均量线
4. 牛熊不败
5. 三外有三
6. 喜鹊闹梅
    7. 
7. 切割线
    8. 一阳穿四线
    9. 量站上5日线
    10. 量比大于3%几率非常大
8. 故地重游
9. 开闸放水
10. 强势牛回头
11. 倒挂金钩
    12. 均线多头排列
    13. 高开3%左右
    14. 5日线附近可以开买
12. 蹄子线
13. 金字塔
14. 三步选股
15. 双锤筑底
16. 三只天鹅
17. 攻击线
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[股票线图]]></title>
    <link href="http://blog.izgnod.com/14723721762973.html"/>
    <updated>2016-08-28T16:16:16+08:00</updated>
    <id>http://blog.izgnod.com/14723721762973.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>k线</p>

<ol>
<li><p>锤子线和上吊线：</p>

<ol>
<li><p>定义： 锤子线和上吊线是相对于增长和下跌来说的，如果后市是上涨那么久叫锤子线，如果是下跌，那么就叫上吊线。如图：<br/>
<img src="media/14723721762973/14723767546699.jpg" alt=""/></p></li>
<li><p>使用前提： </p>

<ol>
<li>长时间的下跌，出现锤子线，或者长时间的上涨出现锤子线(上吊线)</li>
<li>下影线要是实体的2倍以上。</li>
<li>一般是没有上影线，如果有也是很短的</li>
</ol></li>
<li><p>如何使用：</p>

<ol>
<li>锤子线的出现时证明着走向有很大的可能进行逆转，当长期下跌，在底部出现锤子线，很可能已经找到支撑位，空头试图拉低，但是被多头拉回，空头的企图没有得逞，这就说明此时多头是占主。</li>
<li>何时出手，如果是锤子之后上涨趋势，那么第二天高开跳空或者是价位到达前一天锤子线实体的收盘价可出手，如果开始是下降趋势，然后反弹，反弹到前一天锤子线实体的收盘价可出手买入。如果是上吊线，那么最好早抛。 </li>
</ol></li>
</ol></li>
</ol></li>
<li><p>5日，10日，20日，30日，60日平均线</p></li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[股票量价比]]></title>
    <link href="http://blog.izgnod.com/14723615341044.html"/>
    <updated>2016-08-28T13:18:54+08:00</updated>
    <id>http://blog.izgnod.com/14723615341044.html</id>
    <content type="html"><![CDATA[
<ol>
<li>价增量升

<ol>
<li>定义：股价随着股票的成交量上涨。</li>
<li>信号：一般来说这是股票上涨的信号</li>
</ol></li>
<li>价增量减

<ol>
<li>定义： 价格上涨，成交量反跌。</li>
<li>信号： 股票下跌信号，多头占主力，但是由于成交量的低迷，多头无法长时间维持，最终下跌。</li>
</ol></li>
<li>价减量减

<ol>
<li>定义： 价格下降，成交量减少。</li>
<li>信号： 股票上涨信号， 卖方是主力，并且持股坚定，不轻易出，卖方看向高位，等待拉高。</li>
</ol></li>
<li>价减量升：

<ol>
<li>定义：价格下降，成交量升高。</li>
<li>信号： 股票下跌信号，空头占优，不坚定的卖方出货，空头打压。</li>
</ol></li>
</ol>

<p><strong>总结：价格和成交量保持一致的增长，降低态势，说明多头占主力，反之空头占主力，这也就影响到了股票的趋势。</strong></p>

<ol>
<li><p>天量天价</p>

<ol>
<li>股价上行应该是一个渐进的过程，成交量的方法</li>
<li><p>要有一段时间的上涨<br/>
放量滞涨，天量天价的一个特征，廊坊发展，国中水务。<br/>
天量天价不要再买入了，是卖出的信号。</p>

<p>上证指数8天结构的调整,第9天是一个变盘的，跌破20日线是向下，但是目前是5日线和20日线震荡，8 + 5 = 13天的结构，回落，再反弹，再选择方向，大概方向是偏好的。突破5日线或者跌破20日线。</p>

<ol>
<li>脉冲式建仓，回落0.382，买入</li>
<li>回落式建仓</li>
<li>回落反拉式建仓</li>
</ol></li>
</ol></li>
<li><p>地量地价<br/>
放量不是买点，放量之后再缩量就是买点</p></li>
<li><p>底部放量</p></li>
</ol>

<p>蹄子线： 就是涨跌不超过百分之三，大部分情况是庄家吸筹</p>

<p>买阴线，卖阳线<br/>
买缩量，卖放量</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql主从配置]]></title>
    <link href="http://blog.izgnod.com/14719510431478.html"/>
    <updated>2016-08-23T19:17:23+08:00</updated>
    <id>http://blog.izgnod.com/14719510431478.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">PostgreSql主从配置</h2>

<ol>
<li><p>PostgreSql安装：</p>

<ol>
<li><p>导入PostgreSql 9.5 源</p>

<pre><code>$rpm -Uvh http://yum.postgresql.org/9.5/redhat/rhel-7-x86_64/pgdg-centos95-9.5-2.noarch.rpm
</code></pre></li>
<li><p>安装Postgresql</p>

<pre><code>  $yum install postgresql95-server postgresql95 # 这里一般是会安装最新的9.5稳定版，如果用到Postgresql插件，需要安装扩展，建议安装方式： yum install postgresql95*
</code></pre></li>
<li><p>初始化目录结构</p>

<pre><code>  $/usr/pgsql-9.5/bin/postgresql95-setup initdb #这里是Centos7 的目录位置
</code></pre></li>
<li><p>启动（这个可以在后面的主从配置完成之后进行启动）</p>

<pre><code>  $service  postgresql-9.5 start
  $chkconfig postgresql-9.5 on #设置开机启动
</code></pre></li>
</ol></li>
<li><p>PostgreSql 主从配置意义：</p>

<ol>
<li><p>主从配置能够在一台主机宕机的情况下立马切换到另外一台主机上，减少损失</p></li>
<li><p>主从配置能够在读写分离，减轻数据库的压力,主库进行写，从库进行读。</p></li>
<li><p>主从配置能够保证多数据库中的数据一致性。</p></li>
</ol></li>
<li><p>主从配置流程：<br/>
注意：这里使用的是Postgresql 9.5.3进行。由于Postgresql版本之间会有细微的差别。</p>

<ol>
<li><p>Master 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby         # wal 日志的级别
max_wal_senders = 5             # 控制主库最多可以有多少个并发的standby数据库；
wal_keep_segments = 64          # 16M为单位，wal日志生成的单位，尽量的设置较大，防止日志没有来得及到standby就被循环覆盖了，这个如果数据量大的时候要慎重。
synchronous_standby_names = &#39;*&#39; #synchronous_standby_names 这个参数对应着slave配置文件中的recovery.conf 中的primary_conninfo
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code># local      DATABASE  USER  METHOD  [OPTIONS]
# host       DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostssl    DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostnossl  DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
#第一列是指定能够连接数据库的类型，local是本地连接，host是远程的主机。
#第二列是指能够连接那些数据库
#第三列是哪个用户能够连接数据库
#第四列是地址
#第五列是认证的方式
local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre>

<p>配置说明：</p>

<ol>
<li>允许本地的postgres连接</li>
<li>允许所有的本地连接认证方式是获取本地的操作系统的用户名。</li>
</ol></li>
</ol></li>
<li><p>Slave 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby
max_connections = 1000
hot_standby = on
hot_standby_feedback = on
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code>local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre></li>
<li><p>配置: recovery.conf文件</p>

<pre><code>primary_conninfo = &#39;host=x.x.x.x user=test password=123 port=5432&#39;
EOF
</code></pre></li>
</ol></li>
<li><p>过程如下：</p>

<ol>
<li><p>Master</p>

<ol>
<li>启动Mater节点（没有任何的主从配置过程）</li>
<li><p>修改postgres的密码, 创建主从同步需要的账号</p>

<pre><code>su postgres
psql -c &quot;ALTER USER postgres WITH PASSWORD &#39;123&#39;;&quot;
psql -c &quot; CREATE ROLE repluser REPLICATION LOGIN PASSWORD &#39;123&#39;;&quot;
</code></pre></li>
<li><p>然后修改配置成如上的配置。</p></li>
<li><p>重启Master</p></li>
</ol></li>
<li><p>Master打开备份状态：</p>

<pre><code>```
psql -U postgres -c &quot;select pg_start_backup(&#39;initial_backup&#39;);&quot;
```
</code></pre>

<ol>
<li><p>将内容拷贝到远程的slave节点。</p>

<pre><code>rsync -cva --inplace --exclude=*pg_xlog* /var/lib/pgsql/9.5/data/ slave_ipaddress:/var/lib/pgsql/9.5/data/
</code></pre></li>
<li><p>退出备份状态</p>

<pre><code>psql -U postgres -c &quot;select pg_stop_backup();&quot;
</code></pre></li>
</ol></li>
</ol></li>
<li><p>Slave</p>

<ol>
<li>修改成如上的slave配置</li>
<li><p>注意一下/var/lib/pgsql/9.5/data/目录的权限问题，尤其是recovery.conf</p>

<pre><code>chown -R postgres.postgres /var/lib/pgsql/9.5/data/
</code></pre></li>
</ol></li>
</ol></li>
<li><p>检验方式：<br/>
    输入一下命令：</p>

<pre><code>```
select * from pg_stat_replication;
```

可以从输出的信息中看到是否同步成功。
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx HTTP2.0]]></title>
    <link href="http://blog.izgnod.com/14719476150773.html"/>
    <updated>2016-08-23T18:20:15+08:00</updated>
    <id>http://blog.izgnod.com/14719476150773.html</id>
    <content type="html"><![CDATA[
<p>Nginx 从1.9.5已经能够支持HTTP2.0，但是对Openssl版本有要求，下面是过程：</p>

<h2 id="toc_0">环境准备：</h2>

<pre><code>$yum install gcc gcc-c++ autoconf automake zlib zlib-devel pcre-devel
</code></pre>

<h2 id="toc_1">编译Nginx版本：</h2>

<pre><code>$wget http://nginx.org/download/nginx-1.11.1.tar.gz
$tar xf /nginx-1.10.0.tar.gz
$./configure \
--prefix=/etc/nginx\
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-openssl=/usr/src/openssl-1.0.2h \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_sub_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_mp4_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_random_index_module \
--with-http_secure_link_module \
--with-http_stub_status_module \
--with-http_auth_request_module \
--with-mail \
--with-debug \
--with-mail_ssl_module \
--with-file-aio \
--with-ipv6 \
--with-threads \
--with-stream \
--with-stream_ssl_module \
--with-http_slice_module \
--with-http_v2_module
$make &amp;&amp; make install 
</code></pre>

<h2 id="toc_2">修改配置并且运行</h2>

<p>1) 修改配置：</p>

<pre><code>$修改配置文件：
添加：listen 443 ssl http2;
server_name x.17mei.cn;
#ssl on;
ssl_certificate /etc/cert1.pem;
ssl_certificate_key /etc/privkey1.pem;
</code></pre>

<p>2) 运行：<br/>
    1. 可执行文件在objs 目录下，直接可以使用。<br/>
    2. 运行过程例如：</p>

<pre><code>    ```
    $./nginx -c /etc/nginx/nginx.conf
    ```
</code></pre>

<h2 id="toc_3">效果：</h2>

<pre><code>能够在浏览器审核中，看到Network-&gt;Protocol中有h2等关键字，说明http2已经成功。
</code></pre>

<p><img src="http://o9l83saod.bkt.clouddn.com/http2.0.png" alt="Kubernets 架构图 v1"/></p>

]]></content>
  </entry>
  
</feed>
