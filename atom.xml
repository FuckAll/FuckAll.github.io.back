<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[重剑无锋，大巧不工。]]></title>
  <link href="https://fuckall.github.io/atom.xml" rel="self"/>
  <link href="https://fuckall.github.io/"/>
  <updated>2016-08-23T19:34:44+08:00</updated>
  <id>https://fuckall.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql主从配置]]></title>
    <link href="https://fuckall.github.io/14719510431478.html"/>
    <updated>2016-08-23T19:17:23+08:00</updated>
    <id>https://fuckall.github.io/14719510431478.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">PostgreSql主从配置</h2>

<ol>
<li><p>PostgreSql安装：</p>

<ol>
<li><p>导入PostgreSql 9.5 源</p>

<pre><code>$rpm -Uvh http://yum.postgresql.org/9.5/redhat/rhel-7-x86_64/pgdg-centos95-9.5-2.noarch.rpm
</code></pre></li>
<li><p>安装Postgresql</p>

<pre><code>  $yum install postgresql95-server postgresql95 # 这里一般是会安装最新的9.5稳定版，如果用到Postgresql插件，需要安装扩展，建议安装方式： yum install postgresql95*
</code></pre></li>
<li><p>初始化目录结构</p>

<pre><code>  $/usr/pgsql-9.5/bin/postgresql95-setup initdb #这里是Centos7 的目录位置
</code></pre></li>
<li><p>启动（这个可以在后面的主从配置完成之后进行启动）</p>

<pre><code>  $service  postgresql-9.5 start
  $chkconfig postgresql-9.5 on #设置开机启动
</code></pre></li>
</ol></li>
<li><p>PostgreSql 主从配置意义：</p>

<ol>
<li><p>主从配置能够在一台主机宕机的情况下立马切换到另外一台主机上，减少损失</p></li>
<li><p>主从配置能够在读写分离，减轻数据库的压力,主库进行写，从库进行读。</p></li>
<li><p>主从配置能够保证多数据库中的数据一致性。</p></li>
</ol></li>
<li><p>主从配置流程：<br/>
注意：这里使用的是Postgresql 9.5.3进行。由于Postgresql版本之间会有细微的差别。</p>

<ol>
<li><p>Master 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby         # wal 日志的级别
max_wal_senders = 5             # 控制主库最多可以有多少个并发的standby数据库；
wal_keep_segments = 64          # 16M为单位，wal日志生成的单位，尽量的设置较大，防止日志没有来得及到standby就被循环覆盖了，这个如果数据量大的时候要慎重。
synchronous_standby_names = &#39;*&#39; #synchronous_standby_names 这个参数对应着slave配置文件中的recovery.conf 中的primary_conninfo
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code># local      DATABASE  USER  METHOD  [OPTIONS]
# host       DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostssl    DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostnossl  DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
#第一列是指定能够连接数据库的类型，local是本地连接，host是远程的主机。
#第二列是指能够连接那些数据库
#第三列是哪个用户能够连接数据库
#第四列是地址
#第五列是认证的方式
local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre>

<p>配置说明：</p>

<ol>
<li>允许本地的postgres连接</li>
<li>允许所有的本地连接认证方式是获取本地的操作系统的用户名。</li>
</ol></li>
</ol></li>
<li><p>Slave 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby
max_connections = 1000
hot_standby = on
hot_standby_feedback = on
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code>local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre></li>
<li><p>配置: recovery.conf文件</p>

<pre><code>primary_conninfo = &#39;host=x.x.x.x user=test password=123 port=5432&#39;
EOF
</code></pre></li>
</ol></li>
<li><p>过程如下：</p>

<ol>
<li><p>Master</p>

<ol>
<li>启动Mater节点（没有任何的主从配置过程）</li>
<li><p>修改postgres的密码, 创建主从同步需要的账号</p>

<pre><code>su postgres
psql -c &quot;ALTER USER postgres WITH PASSWORD &#39;123&#39;;&quot;
psql -c &quot; CREATE ROLE repluser REPLICATION LOGIN PASSWORD &#39;123&#39;;&quot;
</code></pre></li>
<li><p>然后修改配置成如上的配置。</p></li>
<li><p>重启Master</p></li>
</ol></li>
<li><p>Master打开备份状态：</p>

<pre><code>```
psql -U postgres -c &quot;select pg_start_backup(&#39;initial_backup&#39;);&quot;
```
</code></pre>

<ol>
<li><p>将内容拷贝到远程的slave节点。</p>

<pre><code>rsync -cva --inplace --exclude=*pg_xlog* /var/lib/pgsql/9.5/data/ slave_ipaddress:/var/lib/pgsql/9.5/data/
</code></pre></li>
<li><p>退出备份状态</p>

<pre><code>psql -U postgres -c &quot;select pg_stop_backup();&quot;
</code></pre></li>
</ol></li>
</ol></li>
<li><p>Slave</p>

<ol>
<li>修改成如上的slave配置</li>
<li><p>注意一下/var/lib/pgsql/9.5/data/目录的权限问题，尤其是recovery.conf</p>

<pre><code>chown -R postgres.postgres /var/lib/pgsql/9.5/data/
</code></pre></li>
</ol></li>
</ol></li>
<li><p>检验方式：<br/>
    输入一下命令：</p>

<pre><code>```
select * from pg_stat_replication;
```

可以从输出的信息中看到是否同步成功。
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx HTTP2.0]]></title>
    <link href="https://fuckall.github.io/14719476150773.html"/>
    <updated>2016-08-23T18:20:15+08:00</updated>
    <id>https://fuckall.github.io/14719476150773.html</id>
    <content type="html"><![CDATA[
<p>Nginx 从1.9.5已经能够支持HTTP2.0，但是对Openssl版本有要求，下面是过程：</p>

<h2 id="toc_0">环境准备：</h2>

<pre><code>$yum install gcc gcc-c++ autoconf automake zlib zlib-devel pcre-devel
</code></pre>

<h2 id="toc_1">编译Nginx版本：</h2>

<pre><code>$wget http://nginx.org/download/nginx-1.11.1.tar.gz
$tar xf /nginx-1.10.0.tar.gz
$./configure \
--prefix=/etc/nginx\
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-openssl=/usr/src/openssl-1.0.2h \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_sub_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_mp4_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_random_index_module \
--with-http_secure_link_module \
--with-http_stub_status_module \
--with-http_auth_request_module \
--with-mail \
--with-debug \
--with-mail_ssl_module \
--with-file-aio \
--with-ipv6 \
--with-threads \
--with-stream \
--with-stream_ssl_module \
--with-http_slice_module \
--with-http_v2_module
$make &amp;&amp; make install 
</code></pre>

<h2 id="toc_2">修改配置并且运行</h2>

<p>1) 修改配置：</p>

<pre><code>$修改配置文件：
添加：listen 443 ssl http2;
server_name x.17mei.cn;
#ssl on;
ssl_certificate /etc/cert1.pem;
ssl_certificate_key /etc/privkey1.pem;
</code></pre>

<p>2) 运行：<br/>
    1. 可执行文件在objs 目录下，直接可以使用。<br/>
    2. 运行过程例如：</p>

<pre><code>    ```
    $./nginx -c /etc/nginx/nginx.conf
    ```
</code></pre>

<h2 id="toc_3">效果：</h2>

<pre><code>能够在浏览器审核中，看到Network-&gt;Protocol中有h2等关键字，说明http2已经成功。
</code></pre>

<p><img src="http://o9l83saod.bkt.clouddn.com/http2.0.png" alt="Kubernets 架构图 v1"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubernetes应用的滚动升级]]></title>
    <link href="https://fuckall.github.io/14719470938560.html"/>
    <updated>2016-08-23T18:11:33+08:00</updated>
    <id>https://fuckall.github.io/14719470938560.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">传统的高可用步骤：</h2>

<ol>
<li>将版本的业务进行启动</li>
<li>切换nginx等的配置，切换生产环境</li>
<li>检查上线代码是否有问题</li>
<li>如果没有问题就继续，如果有问题快速的切换配置，将版本快速的回退到上一个版本。
这样做的优缺点：

<ul>
<li>先说优点

<ul>
<li>回滚速度快，能够在第一时间发现错误.</li>
</ul></li>
<li>再说缺点：

<ul>
<li>过多的人工操作，导致人为失误很大程度上影响发布质量。</li>
</ul></li>
</ul></li>
</ol>

<h2 id="toc_1">Kubernetes 方式滚动升级：</h2>

<ol>
<li>升级过程：

<ul>
<li>和传统的滚动升级的思路是一样的，即将新的pod升级上去，然后慢慢的将旧的pod数量降到0，从而实现升级。</li>
</ul></li>
<li><p>下面演示升级过程：</p>

<ol>
<li><p>本地微服务：</p>

<pre><code>$kubectl get rc 
NAME           DESIRED   CURRENT   AGE
account        2         2         1h
activity       2         2         1h

</code></pre></li>
<li><p>服务升级：</p>

<pre><code> $[root@ali-k8s-03 rc]# kubectl rolling-update account --image=reg.17mei.top/account/8092af07-account:v1.2.1
 Created account-e041dc4989c5cd11b305bab7075dd2e7
 Scaling up account-e041dc4989c5cd11b305bab7075dd2e7 from 0 to 2, scaling down account from 2 to 0 (keep 2 pods available, don&#39;t exceed 3 pods)
 Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 1
 Scaling account down to 1
 Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 2
 Scaling account down to 0
 Update succeeded. Deleting old controller: account
 Renaming account-e041dc4989c5cd11b305bab7075dd2e7 to account
 replicationcontroller &quot;account&quot; rolling updated
</code></pre>

<ul>
<li>过程解释：首先，k8s创建一个新的RC，名字叫account-e041dc4989c5cd11b305bab7075dd2e7，总数为2个pod，这个过程是保证有两个pods是可用的。最终滚动升级完成。</li>
</ul></li>
<li><p>服务回滚：<br/>
如果发布的过程中发现有问题，那么就需要回滚操作，下面是回滚操作的步骤：</p>

<pre><code>account                                     2         2         47m
activity                                    2         2         2h
activity-db96883e53ab1ed3f11a99ddfbdf31f7   1         1         28m
#此时用activity进行回滚演示，因为已经发布完成的就不能直接回滚，已经发布的回滚相当于一次从新的发布，此时如果想要回滚操作的话就是直接进行下面的操作
$ kubectl rolling-update activity --rollback
</code></pre></li>
</ol></li>
</ol>

<h2 id="toc_2">我是如何进行Kubernetes进行应用的升级的：</h2>

<ol>
<li><p>以上两种方式遇到的问题：</p>

<ul>
<li><p>先说kubernets.</p>

<ol>
<li>Kubernetes滚动升级的方式对于我这种使用配置比较低的机器，速度较慢，时间成本高.</li>
<li>回滚的速度更加的慢，有种想死的冲动。</li>
<li>发到线上测试人员发现问题要立马回滚，搞得大家都很紧张。</li>
</ol></li>
<li><p>再说传统的方式</p>

<ol>
<li>部署速度慢，大公司有专门的代码发布平台，小公司可能就手动发布了。</li>
<li>人工出错情况多，由于一次上线需要很多的步骤所以人为出错的可能性就很高。</li>
<li>因为代码的运行环境问题引发的问题是很难排除的，也许就是一个软件的版本问题。</li>
</ol></li>
<li><p>那么我是如何使用的。</p>

<ol>
<li>双份生产环境（业务量不大，不需要更多的生产环境），production01 和 production02，可以同时使用，也可以有一个备用，看业务量和对业务高可用的要求衡量。</li>
<li>每个微服务有一个yaml配置文件，用来快速升级部署。</li>
<li>升级过程：
  1) 首先将nginx对应组的业务下线，nginx已经做的很好了，能够平滑的下线。
  2) 升级刚才下线的一组服务，过程是删除一组服务，然后重新用新的配置文件上线一组服务。
  3) 刚上线的一组服务可以进行测试。无论测试多久都不会影响。
  4) 测试没有问题之后，可以切换nginx配置将应用上线。</li>
<li>升级过程出现问题回滚：

<ol>
<li>如果发布的过程中发现有问题，那么直接停止升级或者升级完成，因为是在一组下线的生产环境中，都不会发生问题。</li>
</ol></li>
<li>升级成功之后，将另外一组没有升级的线上节点不做任何的处理，防止有Bug要回滚到上一个版本。</li>
</ol></li>
</ul></li>
</ol>

<h2 id="toc_3">总结：</h2>

<pre><code>两个线上环境，快速升级和回滚都有好处。综合了一下传统的升级方式和Kubernetes的升级方式。早安，上海。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 基础]]></title>
    <link href="https://fuckall.github.io/14719470176268.html"/>
    <updated>2016-08-23T18:10:17+08:00</updated>
    <id>https://fuckall.github.io/14719470176268.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>服务器响应：</p>

<ol>
<li>1xx 提示信息 - 表示请求被成功接收，继续处理</li>
<li>2xx 成功 - 表示清酒已经被成功接收，理解，接收</li>
<li>3xx 重定向 - 要完成请求必须要做进一步的处理</li>
<li>4xx 客户端错误 - 请求有语法错误或者无法实现</li>
<li>5xx 服务端错误 - 服务端未能实现合法的请求</li>
</ol></li>
<li><p>HTTP协议的无状态和Keep-alive的区别：</p>

<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。<br/>
   从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let's Encrypt 获取Nginx证书]]></title>
    <link href="https://fuckall.github.io/14719253380529.html"/>
    <updated>2016-08-23T12:08:58+08:00</updated>
    <id>https://fuckall.github.io/14719253380529.html</id>
    <content type="html"><![CDATA[
<p>Let&#39;s Encrypt作为一个公益项目，给我们带来最大的好处就是能够免费的获取证书，而且申请过程简单，证书有效时间为90天，建议60天的时候主动更新证书。</p>

<hr/>

<h2 id="toc_0">流程以及结果：</h2>

<ol>
<li>安装let&#39;s encrypt 客户端</li>
<li>多个证书申请</li>
<li>定期更新证书</li>
</ol>

<h2 id="toc_1">准备：</h2>

<ol>
<li>首先要有一台nginx服务器</li>
<li>有域名的控制权，也就是可以解析到nginx服务器上</li>
<li>这里使用的是CentOS 7</li>
</ol>

<h2 id="toc_2">流程开始：</h2>

<ol>
<li><p>安装必要的软件</p>

<pre><code> sudo yum -y install git bc
</code></pre></li>
<li><p>安装let&#39;s encrypt 客户端</p>

<pre><code class="language-bash">  $sudo git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt
</code></pre></li>
<li><p>获取证书</p>

<ol>
<li><p>修该nginx 配置文件,在Nginx的/etc/nginx/conf.d/default.conf文件中添加如下的内容。</p>

<pre><code class="language-bash">$ location ~ /.well-known {
allow all;
}
 ```
</code></pre></li>
<li><p>重启nginx</p>

<pre><code class="language-bash">$ sudo systemctl restart nginx
</code></pre></li>
<li><p>申请证书</p>

<pre><code class="language-bash">$ cd /opt/letsencrypt
$./letsencrypt-auto certonly -a webroot --webroot-path=/usr/share/nginx/html -d example.com -d www.example.com
</code></pre>

<p>这里的webroot，我用的是默认的，应为我的nginx是yum直接安装的，如果是自己编译的版本请指定，这样let&#39;s encrypt 才能够验证域名的绝对控制权，-d 后面的参数可以选择多个，但是这几个域名都要解析到本机的nginx上面。</p></li>
<li><p>填写邮箱地址</p>

<ol>
<li><p>注意：这里是let&#39;s encrypt 的客户端的ui界面，只要将你的邮箱地址填入即可，这个邮箱的作用是用来进行账号找回的，也可以下次重新的申请，但是如果要申请的话你要把所有的上面的程序走一遍，但是如果同样的账号，那么至于要一条命令重新的申请以下就好了，比较方便。<br/>
然后一路的同意，最后是输出信息，有Congratulations!等字眼，说明申请已经成功了，注意这时候的输出信息，这些信息中包括了你的证书在什么地方，证书过期证书等。</p></li>
<li><p>输出信息,例如:</p></li>
</ol>

<pre><code class="language-bash">IMPORTANT NOTES:
If you lose your account credentials, you can recover through
e-mails sent to sammy@digitalocean.com
Congratulations! Your certificate and chain have been saved at
/etc/letsencrypt/live/example.com/fullchain.pem. Your
cert will expire on 2016-03-15. To obtain a new version of the
certificate in the future, simply run Let&#39;s Encrypt again.
Your account credentials have been saved in your Let&#39;s Encrypt
configuration directory at /etc/letsencrypt. You should make a
secure backup of this folder now. This configuration directory will
also contain certificates and private keys obtained by Let&#39;s
Encrypt so making regular backups of this folder is ideal.
If like Let&#39;s Encrypt, please consider supporting our work by:

Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
Donating to EFF:                    https://eff.org/donate-len
</code></pre>

<ol>
<li><p>申请之后的产物</p>

<ul>
<li>cert.pem 这个就是域名的证书，Nginx 需要。</li>
<li>privkey.pem 这个是秘钥,Nginx 需要。</li>
<li>chain.pem 这信任let&#39;s encrypt 的证书。</li>
<li>fullchain.pem 这个是cert.pem 和 chain.pem证书的结合体。</li>
<li>chain.pem 这是是一个let&#39;s Encrypt 用来找回证书的一个标志文件</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>Nginx 配置使用证书：</p>

<p>在对应的域名的配置文件中加入：</p>

<pre><code>listen 443 ssl;
server_name example.com www.example.com;
ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
</code></pre></li>
<li><p>重启nginx，并且https请求。</p></li>
<li><p>定时任务，每周进行一次证书的申请以及重启nginx</p>

<pre><code> $sudo crontab -e
</code></pre>

<p>添加如下定时任务： </p>

<pre><code>  30 2 * * 1 /opt/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/log/le-renew.log
  35 2 * * 1 /usr/bin/systemctl reload nginx
</code></pre></li>
</ol>

<h2 id="toc_3">总结:以上步骤很简单，并且很好用，如果以后需要升级let&#39;s encrypt客户端软件，直接git pull即可，非常方便。</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Registry]]></title>
    <link href="https://fuckall.github.io/14719166233226.html"/>
    <updated>2016-08-23T09:43:43+08:00</updated>
    <id>https://fuckall.github.io/14719166233226.html</id>
    <content type="html"><![CDATA[
<ol>
<li>安全问题：能够在不泄露公司代码的情况下，存储镜像</li>
<li>可用性： 不依赖其他的第三方的docker仓库</li>
<li>Ci： 公司部署方式的改变，Docker Registry成为不可或缺的一部分。</li>
</ol>

<h2 id="toc_0">搭建准备：</h2>

<ol>
<li>镜像：registry:2</li>
<li>镜像存储的目录：例如：/DockerRegistry/</li>
<li>证书,安全证书</li>
</ol>

<h2 id="toc_1">搭建过程：</h2>

<ol>
<li>首先拉取Docker Registry镜像(由于国内墙的问题,使用DaoCloud镜像)<br/></li>
</ol>

<pre><code>docker pull daocloud.io/library/registry:2.4.1
</code></pre>

<ol>
<li>创建镜像存储目录：</li>
</ol>

<pre><code>$mkdir /DockerRegistry/
</code></pre>

<ol>
<li>创建证书文件目录并且放入证书：</li>
</ol>

<pre><code>$mkdir /DockerRegistry/cert 
</code></pre>

<ol>
<li>创建Docker Registry登录密码：</li>
</ol>

<pre><code class="language-bash">$mkdir auth
$docker run --entrypoint htpasswd daocloud.io/library/registry:2.4.1  -Bbn testuser testpassword &gt; auth/htpasswd
</code></pre>

<ol>
<li>启动Registry (注意下面的证书都是要改为自己的证书)</li>
</ol>

<pre><code class="language-bash">$docker run -d -p 5000:5000 --restart=always --name registry \
  -v `pwd`/auth:/auth \
  -e &quot;REGISTRY_AUTH=htpasswd&quot; \
  -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
  daocloud.io/library/registry:2.4.1
</code></pre>

<ol>
<li>添加一个可视化的界面 </li>
</ol>

<pre><code class="language-bash">$docker run \
  -d \
  -e ENV_DOCKER_REGISTRY_HOST=ENTER-YOUR-REGISTRY-HOST-HERE \
  -e ENV_DOCKER_REGISTRY_PORT=ENTER-PORT-TO-YOUR-REGISTRY-HOST-HERE \
  -e ENV_MODE_BROWSE_ONLY=false
  -p 8080:80 \
  konradkleine/docker-registry-frontend:v2
</code></pre>

<ol>
<li>nginx配置 (添加nginx配置)</li>
</ol>

<pre><code class="language-nginx.conf">$server {
    server_name dev;
    location / {
        proxy_pass http://x.x.x.x:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection &quot;&quot;;
    }
}
</code></pre>

<h2 id="toc_2">总结：</h2>

<p>以上的步骤比较简单，已经满足大部分的需求，更加高端的需求可以定制registry的config.yaml文件。<br/>
起始可以在第六步的时候不必要映射端口到host，包括第七部也可以不用，因为相同在同一台机器上的docker是可以直接连接。</p>

]]></content>
  </entry>
  
</feed>
