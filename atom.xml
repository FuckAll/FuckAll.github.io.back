<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[重剑无锋，大巧不工。]]></title>
  <link href="http://blog.izgnod.com/atom.xml" rel="self"/>
  <link href="http://blog.izgnod.com/"/>
  <updated>2016-08-29T18:24:14+08:00</updated>
  <id>http://blog.izgnod.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[技术类博客收集]]></title>
    <link href="http://blog.izgnod.com/14727777201831.html"/>
    <updated>2016-09-02T08:55:20+08:00</updated>
    <id>http://blog.izgnod.com/14727777201831.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">精华网站</h2>

<ol>
<li><a href="http://blog.jobbole.com/">伯乐在线</a>
主要是一些原创的聚合站点</li>
<li><a href="http://www.importnew.com/">ImportNew</a>
Java &amp; Android 技术分享</li>
<li><a href="http://segmentfault.com/">Segmentfault</a>
年轻开发者社区；最前沿的技术问答，最纯粹的技术切磋</li>
<li><a href="http://www.infoq.com/cn/">InfoQ</a>
InfoQ - 促进软件开发领域知识与创新的传播</li>
<li><a href="http://www.v2ex.com/">V2EX</a>
V2EX 是创意工作者们的社区。这里目前汇聚了超过 75000 名主要来自互联网行业、游戏行业和媒体行业的创意工作</li>
</ol>

<h2 id="toc_1">互联网公司团队博客</h2>

<ol>
<li><a href="http://www.jianshu.com/p/ca676b17603e">腾讯全端 AlloyTeam 团队 Blog</a>
Tencent  前端</li>
<li><a href="http://blogs.360.cn/">奇虎360技术博客</a></li>
<li><a href="http://tech.meituan.com/">美团技术团队</a></li>
<li><a href="http://tech.uc.cn/">UC技术博客</a></li>
<li><a href="http://www.jianshu.com/p/ca676b17603e">Tecent CDC</a></li>
</ol>

<h2 id="toc_2">业界大牛博客推荐</h2>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://coolshell.cn/">酷 壳</a></li>
<li><a href="http://it.deepinmind.com/">Java 译站</a></li>
<li><a href="http://www.aips.me/">周良的博客</a></li>
<li><a href="http://www.itzhai.com/">IT 宅</a></li>
<li><a href="http://macshuo.com/">MacTalk-池建强的随想录</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://yes2.me/">钟超&quot;s Blogs</a></li>
<li><a href="http://mindhacks.cn/">刘未鹏 | MIND HACKS</a></li>
<li><a href="http://www.raychase.net/">四火的唠叨</a></li>
<li><a href="http://blog.codingnow.com/">云风的 BLOG</a></li>
<li><a href="http://dbanotes.net/">Fenng</a></li>
<li><a href="http://beyondvincent.com/">破船之家</a></li>
<li><a href="http://blog.zhaojie.me/">老赵点滴 - 追求编程之美</a></li>
<li><a href="http://hedengcheng.com/">何登成的技术博客</a></li>
<li><a href="http://bluedavy.me/">BlueDavy之技术Blog</a></li>
<li><a href="http://ifeve.com/">并发编程网</a></li>
<li><a href="http://timyang.net/">Tim&#39;s blog</a></li>
</ol>

<h2 id="toc_3">外部链接：</h2>

<ol>
<li><a href="http://blogwall.us/">博客墙</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[容器脚本]]></title>
    <link href="http://blog.izgnod.com/14726120122280.html"/>
    <updated>2016-08-31T10:53:32+08:00</updated>
    <id>http://blog.izgnod.com/14726120122280.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">容器清理脚本</h3>

<pre><code>#!/bin/sh

&gt;/tmp/run_image_ids.$$

DOCKER_BIN=/usr/bin/docker
LOG=/var/log/docker-cleanup.log

rm /tmp/run_image_ids.$$

echo &quot;$(date) start-----&quot; &gt;&gt;$LOG

$DOCKER_BIN ps --no-trunc -a -q | while read cid
do
  running=$($DOCKER_BIN inspect -f &#39;{{.State.Running}}&#39; $cid )
  if [ &quot;$running&quot;x = &quot;true&quot;x ]
  then
    id=$($DOCKER_BIN inspect -f &#39;{{.Image}}&#39; $cid )
    echo $id &gt;&gt;/tmp/run_image_ids.$$
    continue
  fi 
  fini=$($DOCKER_BIN inspect -f &#39;{{.State.FinishedAt}}&#39; $cid | awk -F. &#39;{print $1}&#39;)
  diff=$(expr $(date +&quot;%s&quot;) - $(date --date=&quot;$fini&quot; +&quot;%s&quot;))    
  #for MacOs 
  #diff=$(expr $(date +&quot;%s&quot;) - $(date -j -f %Y-%m-%dT%H:%M:%S &quot;$fini&quot; +&quot;%s&quot;))
  if [ $diff -gt 86400 ]
  then
     $DOCKER_BIN rm -v $cid &gt;&gt;$LOG 2&gt;&amp;1
  fi 
done


$DOCKER_BIN images --no-trunc | grep -v REPOSITORY | while read line
do
  repo_tag=$(echo $line | awk &#39;{print $1&quot;:&quot;$2}&#39;)
  image_id=$(echo $line | awk &#39;{print $3}&#39;)
  grep -q $image_id /tmp/run_image_ids.$$
  if [ $? -eq 0 ]
  then
    continue
  fi
  if [ &quot;$repo_tag&quot;x = &quot;&lt;none&gt;:&lt;none&gt;&quot;x ]
  then
    $DOCKER_BIN rmi $image_id &gt;&gt;$LOG 2&gt;&amp;1
  else
    $DOCKER_BIN rmi $repo_tag &gt;&gt;$LOG 2&gt;&amp;1
  fi
done

rm /tmp/run_image_ids.$$


echo &quot;$(date) end-----&quot; &gt;&gt;$LOG
</code></pre>

<p><strong>清理内容</strong><br/>
    1. 停止超过一天的容器<br/>
    2. 一天之内没有运行过容器的镜像</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 基础类型]]></title>
    <link href="http://blog.izgnod.com/14726074871676.html"/>
    <updated>2016-08-31T09:38:07+08:00</updated>
    <id>http://blog.izgnod.com/14726074871676.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量声明</h2>

<ol>
<li><p>不同基础类型的零值</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>

<tbody>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr>
<td>struct</td>
<td>nil</td>
</tr>
<tr>
<td>array</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
</tr>
</tbody>
</table></li>
<li><p>var a int 和 a := 0 的哲学</p>

<ol>
<li><p>var a int </p>

<p>var a int 可以用来声明局部和全局变量,如果不初始化那么就是对应的零值     var a int = 1 可以进行初始化</p></li>
<li><p>a := 0</p>

<p>a := 0 可以用来声明局部变量，但是不能够声明全局变量<br/>
a := 1 显示的进行初始化</p></li>
<li><p>在局部的变量中 var 等价 : ; var 可以使用零值， : 是必须显示指明初始化值</p></li>
<li><p>我的使用习惯</p>

<ol>
<li>全局变量使用 var a int = 0 显示指明初始值</li>
<li>局部变量使用 a := 0 显示指明初始值</li>
</ol></li>
</ol>

<p><strong>注意：</strong><br/>
    var a int 也可以用做 var a = 0,效果是一样的，但是这里尽量的使用显示的指定类型和初始值</p></li>
</ol>

<h2 id="toc_1">字符串拼加性能问题</h2>

<ol>
<li>字符串拼加的三种方式：

<ol>
<li>+=</li>
<li>strings.Join()</li>
<li>bytes.Buffer</li>
</ol></li>
<li><p>比较：</p>

<pre><code>package main
import (
    &quot;fmt&quot;

    &quot;strings&quot;
    &quot;time&quot;
    &quot;bytes&quot;
)

func main() {
    var buffer bytes.Buffer

    s := time.Now()
    for i :=0; i &lt;100000; i++ {
        buffer.WriteString(&quot;test is here\n&quot;)
    }
    buffer.String() // 拼接结果
    e := time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    str := &quot;&quot;
    for i :=0; i &lt;100000; i++ {
        str += &quot;test is here\n&quot;
    }
    e = time.Now()
    fmt.Println(&quot;taked time is &quot;, e.Sub(s).Seconds())

    s = time.Now()
    var sl []string
    for i :=0; i &lt;100000; i++ {
        sl = append(sl, &quot;test is here\n&quot;)
    }
    strings.Join(sl, &quot;&quot;)
    e = time.Now()
    fmt.Println(&quot;taked time is&quot;, e.Sub(s).Seconds())
}
</code></pre>

<p><strong>运行结果</strong></p>

<pre><code>taked time is  0.0039795080000000005
taked time is  13.403575973
taked time is 0.017540489
</code></pre></li>
<li><p>[]byte 和 string </p>

<ol>
<li><p>golang 中的[]byte和string可以方便的转换</p>

<ol>
<li>[]byte -&gt; string
string([]byte) -&gt; string </li>
<li>string -&gt; []byte
[]byte(string) -&gt; []byte</li>
</ol>

<p><strong>golang中[]byte和string的方法基本上是一样的</strong></p></li>
<li><p>byte和string性能问题之buffer</p>

<ol>
<li>golang 中 bytes包中有Buffer类型以及相关方法

<ol>
<li>直接声明： var buffer bytes.Buffer</li>
<li>方法成成：</li>
</ol></li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql语句集锦]]></title>
    <link href="http://blog.izgnod.com/14724588246571.html"/>
    <updated>2016-08-29T16:20:24+08:00</updated>
    <id>http://blog.izgnod.com/14724588246571.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>更正Jsonb中数据：</p>

<ol>
<li><img src="media/14724588246571/14724588641183.jpg" alt=""/></li>
</ol>

<p>将其中不合法的数据改成:[&quot;镭射祛斑&quot;,&quot;c10&quot;, &quot;白瓷娃娃&quot;, &quot;黄雀斑&quot;, &quot;雀斑&quot;, &quot;色斑&quot;,&quot;微整形&quot;]<br/>
语句：<br/>
其中的问题：多个字段在一个双引号中，其中是中文的逗号。</p>

<pre><code>UPDATE table_name SET tags=to_jsonb(string_to_array(jsonb_array_elements_text(tags),&#39;，&#39;)) WHERE tags!=&#39;null&#39;;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postgresql 备份与恢复]]></title>
    <link href="http://blog.izgnod.com/14724369503027.html"/>
    <updated>2016-08-29T10:15:50+08:00</updated>
    <id>http://blog.izgnod.com/14724369503027.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">备份和定时备份</h2>

<ol>
<li><p>备份命令</p>

<pre><code>pg_dump -h host_ip -p host_port -U datebase_user -d database_name -vF c -C -c -f test1.bkp test1 
-a 为只输出数据库中的数据（此处没有用）
-v 打出执行信息
-F 输出为指定的格式 c 为custom
-c dump的时候将drop database xxx 语句放入到dump的内容中
-C dump的时候将Create database xxx 语句放入到dump的内容中
-f 指定输出dump的名称
最后一个为数据库的名字
</code></pre></li>
<li><p>定时命令：</p>

<ol>
<li>脚本内容backup_db.sh(全量导出，这里导出的是自定义格式，只能够被全量恢复和部分恢复)</li>
</ol>

<pre><code>#/bin/bash
DATE=`date +&quot;%Y_%m_%d&quot;`
/usr/bin/pg_dump -U postgres -vF c -C -c -f /share/meidb_$DATE.bak meidb
## 备份到香港阿里云（这里要把key加好）
##chmod 777 /share/meidb_$DATE.bak
/usr/bin/scp -P hostPort -i /root/.ssh/id_rsa /share/meidb_$DATE.bak
root@Hostname:/backup/ &gt;&gt; /share/scp.log 2&gt;&amp;1
</code></pre></li>
</ol>

<h2 id="toc_1">如何恢复数据</h2>

<ol>
<li><p>全量数据恢复方法</p>

<ol>
<li><p>如果需要将原先的库进行删除并且重建</p>

<ol>
<li>执行命令：</li>
</ol>

<pre><code>pg_restore -h host_ip -p host_port -U postgres -d postgres -v -C  -c test1.bkp
</code></pre></li>
</ol></li>
<li><p>部分恢复的方法：</p>

<ol>
<li><p>创建恢复表的目录批量恢复方法：</p>

<ol>
<li>执行命创建恢复目录：</li>
</ol>

<pre><code>pg_restore -l test1db_2016_18_29.bkp -f table.lst
 -l, --list print summarized TOC of the archive
 -f, --file=FILENAME output file name
</code></pre>

<ol>
<li><p>修改恢复表目录：</p>

<ol>
<li><p>修改前内容例如：</p>

<pre><code>; Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
4170; 0 18551 TABLE DATA public activities postgres
4235; 0 0 SEQUENCE SET public activities_num_seq postgres
4172; 0 18564 TABLE DATA public activity_enrolls postgres
4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>将其余的注释，然后只留下需要恢复的表明即可：<br/>
    小技巧：vim替换模式:（:16,78s#<sup>4#;4#g）</sup><br/>
    修改后内容如下(例如要恢复表accounts)：</p>

<pre><code>;     Archive created at 2016-08-29 11:16:17 CST
;     dbname: meidb
;     TOC Entries: 65
;     Compression: -1
;     Dump Version: 1.12-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 9.5.3
;     Dumped by pg_dump version: 9.5.3
;
;
; Selected TOC Entries:
;
;4168; 0 18518 TABLE DATA public account_items postgres
4169; 0 18530 TABLE DATA public accounts postgres
;4170; 0 18551 TABLE DATA public activities postgres
;4235; 0 0 SEQUENCE SET public activities_num_seq postgres
;4172; 0 18564 TABLE DATA public activity_enrolls postgres
;4173; 0 18576 TABLE DATA public balance_changes postgres

</code></pre></li>
<li><p>恢复命令：</p>

<pre><code>pg_restore -U postgres -h hostname -p port -vaxd database_name -L table.lst test1
</code></pre></li>
</ol></li>
</ol></li>
<li><p>指定恢复表的方式</p>

<ol>
<li><p>恢复命令</p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account test1.bkp
</code></pre>

<p><strong>多个文件恢复</strong></p>

<pre><code>pg_restore -U postgres  -v -c -d meidb -t account -t account_items  test.bkp
</code></pre></li>
</ol></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选股模型]]></title>
    <link href="http://blog.izgnod.com/14723863067284.html"/>
    <updated>2016-08-28T20:11:46+08:00</updated>
    <id>http://blog.izgnod.com/14723863067284.html</id>
    <content type="html"><![CDATA[
<pre><code>1. 长阳重炮
    2. 在低位温和放量之后出现了一根带量长阳（或涨停），同时成交量为上叉阳量托，马上直扑追涨。


    3. 量五日线2北，大阳线，实体的上沿可以做多，止损放到下沿
2. 吞并翻转
    3. 第一个交易日长阴（跌停）， 第二个交易日涨停，包容第一个交易日长阴。可以在第二个交易日涨停的刹那追涨买入
3. 螺旋桨
    4. 均线多头排列： 10日线在5日线以上至少
    5. 影线长度8%
    6. 量站上5日均量线
4. 牛熊不败
5. 三外有三
6. 喜鹊闹梅
    7. 
7. 切割线
    8. 一阳穿四线
    9. 量站上5日线
    10. 量比大于3%几率非常大
8. 故地重游
9. 开闸放水
10. 强势牛回头
11. 倒挂金钩
    12. 均线多头排列
    13. 高开3%左右
    14. 5日线附近可以开买
12. 蹄子线
13. 金字塔
14. 三步选股
15. 双锤筑底
16. 三只天鹅
17. 攻击线
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[股票线图]]></title>
    <link href="http://blog.izgnod.com/14723721762973.html"/>
    <updated>2016-08-28T16:16:16+08:00</updated>
    <id>http://blog.izgnod.com/14723721762973.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>k线</p>

<ol>
<li><p>锤子线和上吊线：</p>

<ol>
<li><p>定义： 锤子线和上吊线是相对于增长和下跌来说的，如果后市是上涨那么久叫锤子线，如果是下跌，那么就叫上吊线。如图：<br/>
<img src="media/14723721762973/14723767546699.jpg" alt=""/></p></li>
<li><p>使用前提： </p>

<ol>
<li>长时间的下跌，出现锤子线，或者长时间的上涨出现锤子线(上吊线)</li>
<li>下影线要是实体的2倍以上。</li>
<li>一般是没有上影线，如果有也是很短的</li>
</ol></li>
<li><p>如何使用：</p>

<ol>
<li>锤子线的出现时证明着走向有很大的可能进行逆转，当长期下跌，在底部出现锤子线，很可能已经找到支撑位，空头试图拉低，但是被多头拉回，空头的企图没有得逞，这就说明此时多头是占主。</li>
<li>何时出手，如果是锤子之后上涨趋势，那么第二天高开跳空或者是价位到达前一天锤子线实体的收盘价可出手，如果开始是下降趋势，然后反弹，反弹到前一天锤子线实体的收盘价可出手买入。如果是上吊线，那么最好早抛。 </li>
</ol></li>
</ol></li>
</ol></li>
<li><p>5日，10日，20日，30日，60日平均线</p></li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[股票量价比]]></title>
    <link href="http://blog.izgnod.com/14723615341044.html"/>
    <updated>2016-08-28T13:18:54+08:00</updated>
    <id>http://blog.izgnod.com/14723615341044.html</id>
    <content type="html"><![CDATA[
<ol>
<li>价增量升

<ol>
<li>定义：股价随着股票的成交量上涨。</li>
<li>信号：一般来说这是股票上涨的信号</li>
</ol></li>
<li>价增量减

<ol>
<li>定义： 价格上涨，成交量反跌。</li>
<li>信号： 股票下跌信号，多头占主力，但是由于成交量的低迷，多头无法长时间维持，最终下跌。</li>
</ol></li>
<li>价减量减

<ol>
<li>定义： 价格下降，成交量减少。</li>
<li>信号： 股票上涨信号， 卖方是主力，并且持股坚定，不轻易出，卖方看向高位，等待拉高。</li>
</ol></li>
<li>价减量升：

<ol>
<li>定义：价格下降，成交量升高。</li>
<li>信号： 股票下跌信号，空头占优，不坚定的卖方出货，空头打压。</li>
</ol></li>
</ol>

<p><strong>总结：价格和成交量保持一致的增长，降低态势，说明多头占主力，反之空头占主力，这也就影响到了股票的趋势。</strong></p>

<ol>
<li><p>天量天价</p>

<ol>
<li>股价上行应该是一个渐进的过程，成交量的方法</li>
<li><p>要有一段时间的上涨<br/>
放量滞涨，天量天价的一个特征，廊坊发展，国中水务。<br/>
天量天价不要再买入了，是卖出的信号。</p>

<p>上证指数8天结构的调整,第9天是一个变盘的，跌破20日线是向下，但是目前是5日线和20日线震荡，8 + 5 = 13天的结构，回落，再反弹，再选择方向，大概方向是偏好的。突破5日线或者跌破20日线。</p>

<ol>
<li>脉冲式建仓，回落0.382，买入</li>
<li>回落式建仓</li>
<li>回落反拉式建仓</li>
</ol></li>
</ol></li>
<li><p>地量地价<br/>
放量不是买点，放量之后再缩量就是买点</p></li>
<li><p>底部放量</p></li>
</ol>

<p>蹄子线： 就是涨跌不超过百分之三，大部分情况是庄家吸筹</p>

<p>买阴线，卖阳线<br/>
买缩量，卖放量</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSql主从配置]]></title>
    <link href="http://blog.izgnod.com/14719510431478.html"/>
    <updated>2016-08-23T19:17:23+08:00</updated>
    <id>http://blog.izgnod.com/14719510431478.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">PostgreSql主从配置</h2>

<ol>
<li><p>PostgreSql安装：</p>

<ol>
<li><p>导入PostgreSql 9.5 源</p>

<pre><code>$rpm -Uvh http://yum.postgresql.org/9.5/redhat/rhel-7-x86_64/pgdg-centos95-9.5-2.noarch.rpm
</code></pre></li>
<li><p>安装Postgresql</p>

<pre><code>  $yum install postgresql95-server postgresql95 # 这里一般是会安装最新的9.5稳定版，如果用到Postgresql插件，需要安装扩展，建议安装方式： yum install postgresql95*
</code></pre></li>
<li><p>初始化目录结构</p>

<pre><code>  $/usr/pgsql-9.5/bin/postgresql95-setup initdb #这里是Centos7 的目录位置
</code></pre></li>
<li><p>启动（这个可以在后面的主从配置完成之后进行启动）</p>

<pre><code>  $service  postgresql-9.5 start
  $chkconfig postgresql-9.5 on #设置开机启动
</code></pre></li>
</ol></li>
<li><p>PostgreSql 主从配置意义：</p>

<ol>
<li><p>主从配置能够在一台主机宕机的情况下立马切换到另外一台主机上，减少损失</p></li>
<li><p>主从配置能够在读写分离，减轻数据库的压力,主库进行写，从库进行读。</p></li>
<li><p>主从配置能够保证多数据库中的数据一致性。</p></li>
</ol></li>
<li><p>主从配置流程：<br/>
注意：这里使用的是Postgresql 9.5.3进行。由于Postgresql版本之间会有细微的差别。</p>

<ol>
<li><p>Master 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby         # wal 日志的级别
max_wal_senders = 5             # 控制主库最多可以有多少个并发的standby数据库；
wal_keep_segments = 64          # 16M为单位，wal日志生成的单位，尽量的设置较大，防止日志没有来得及到standby就被循环覆盖了，这个如果数据量大的时候要慎重。
synchronous_standby_names = &#39;*&#39; #synchronous_standby_names 这个参数对应着slave配置文件中的recovery.conf 中的primary_conninfo
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code># local      DATABASE  USER  METHOD  [OPTIONS]
# host       DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostssl    DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostnossl  DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
#第一列是指定能够连接数据库的类型，local是本地连接，host是远程的主机。
#第二列是指能够连接那些数据库
#第三列是哪个用户能够连接数据库
#第四列是地址
#第五列是认证的方式
local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre>

<p>配置说明：</p>

<ol>
<li>允许本地的postgres连接</li>
<li>允许所有的本地连接认证方式是获取本地的操作系统的用户名。</li>
</ol></li>
</ol></li>
<li><p>Slave 配置：</p>

<ol>
<li><p>配置:postgresql.conf 文件</p>

<pre><code>listen_addresses = &#39;*&#39;          # what IP address(es) to listen on;
wal_level = hot_standby
max_connections = 1000
hot_standby = on
hot_standby_feedback = on
</code></pre></li>
<li><p>配置:pg_hba.conf文件(这个文件主要是用来配置数据库连接权限的)</p>

<pre><code>local   all             postgres                                trust
local   all             all                                     peer
host    all             all             0.0.0.0/0               md5
host    replication     all             0.0.0.0/0               trust
host    all             all             ::1/128                 md5
</code></pre></li>
<li><p>配置: recovery.conf文件</p>

<pre><code>primary_conninfo = &#39;host=x.x.x.x user=test password=123 port=5432&#39;
EOF
</code></pre></li>
</ol></li>
<li><p>过程如下：</p>

<ol>
<li><p>Master</p>

<ol>
<li>启动Mater节点（没有任何的主从配置过程）</li>
<li><p>修改postgres的密码, 创建主从同步需要的账号</p>

<pre><code>su postgres
psql -c &quot;ALTER USER postgres WITH PASSWORD &#39;123&#39;;&quot;
psql -c &quot; CREATE ROLE repluser REPLICATION LOGIN PASSWORD &#39;123&#39;;&quot;
</code></pre></li>
<li><p>然后修改配置成如上的配置。</p></li>
<li><p>重启Master</p></li>
</ol></li>
<li><p>Master打开备份状态：</p>

<pre><code>```
psql -U postgres -c &quot;select pg_start_backup(&#39;initial_backup&#39;);&quot;
```
</code></pre>

<ol>
<li><p>将内容拷贝到远程的slave节点。</p>

<pre><code>rsync -cva --inplace --exclude=*pg_xlog* /var/lib/pgsql/9.5/data/ slave_ipaddress:/var/lib/pgsql/9.5/data/
</code></pre></li>
<li><p>退出备份状态</p>

<pre><code>psql -U postgres -c &quot;select pg_stop_backup();&quot;
</code></pre></li>
</ol></li>
</ol></li>
<li><p>Slave</p>

<ol>
<li>修改成如上的slave配置</li>
<li><p>注意一下/var/lib/pgsql/9.5/data/目录的权限问题，尤其是recovery.conf</p>

<pre><code>chown -R postgres.postgres /var/lib/pgsql/9.5/data/
</code></pre></li>
</ol></li>
</ol></li>
<li><p>检验方式：<br/>
    输入一下命令：</p>

<pre><code>```
select * from pg_stat_replication;
```

可以从输出的信息中看到是否同步成功。
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx HTTP2.0]]></title>
    <link href="http://blog.izgnod.com/14719476150773.html"/>
    <updated>2016-08-23T18:20:15+08:00</updated>
    <id>http://blog.izgnod.com/14719476150773.html</id>
    <content type="html"><![CDATA[
<p>Nginx 从1.9.5已经能够支持HTTP2.0，但是对Openssl版本有要求，下面是过程：</p>

<h2 id="toc_0">环境准备：</h2>

<pre><code>$yum install gcc gcc-c++ autoconf automake zlib zlib-devel pcre-devel
</code></pre>

<h2 id="toc_1">编译Nginx版本：</h2>

<pre><code>$wget http://nginx.org/download/nginx-1.11.1.tar.gz
$tar xf /nginx-1.10.0.tar.gz
$./configure \
--prefix=/etc/nginx\
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-openssl=/usr/src/openssl-1.0.2h \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_sub_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_mp4_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_random_index_module \
--with-http_secure_link_module \
--with-http_stub_status_module \
--with-http_auth_request_module \
--with-mail \
--with-debug \
--with-mail_ssl_module \
--with-file-aio \
--with-ipv6 \
--with-threads \
--with-stream \
--with-stream_ssl_module \
--with-http_slice_module \
--with-http_v2_module
$make &amp;&amp; make install 
</code></pre>

<h2 id="toc_2">修改配置并且运行</h2>

<p>1) 修改配置：</p>

<pre><code>$修改配置文件：
添加：listen 443 ssl http2;
server_name x.17mei.cn;
#ssl on;
ssl_certificate /etc/cert1.pem;
ssl_certificate_key /etc/privkey1.pem;
</code></pre>

<p>2) 运行：<br/>
    1. 可执行文件在objs 目录下，直接可以使用。<br/>
    2. 运行过程例如：</p>

<pre><code>    ```
    $./nginx -c /etc/nginx/nginx.conf
    ```
</code></pre>

<h2 id="toc_3">效果：</h2>

<pre><code>能够在浏览器审核中，看到Network-&gt;Protocol中有h2等关键字，说明http2已经成功。
</code></pre>

<p><img src="http://o9l83saod.bkt.clouddn.com/http2.0.png" alt="Kubernets 架构图 v1"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubernetes应用的滚动升级]]></title>
    <link href="http://blog.izgnod.com/14719470938560.html"/>
    <updated>2016-08-23T18:11:33+08:00</updated>
    <id>http://blog.izgnod.com/14719470938560.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">传统的高可用步骤：</h2>

<ol>
<li>将版本的业务进行启动</li>
<li>切换nginx等的配置，切换生产环境</li>
<li>检查上线代码是否有问题</li>
<li>如果没有问题就继续，如果有问题快速的切换配置，将版本快速的回退到上一个版本。
这样做的优缺点：

<ul>
<li>先说优点

<ul>
<li>回滚速度快，能够在第一时间发现错误.</li>
</ul></li>
<li>再说缺点：

<ul>
<li>过多的人工操作，导致人为失误很大程度上影响发布质量。</li>
</ul></li>
</ul></li>
</ol>

<h2 id="toc_1">Kubernetes 方式滚动升级：</h2>

<ol>
<li>升级过程：

<ul>
<li>和传统的滚动升级的思路是一样的，即将新的pod升级上去，然后慢慢的将旧的pod数量降到0，从而实现升级。</li>
</ul></li>
<li><p>下面演示升级过程：</p>

<ol>
<li><p>本地微服务：</p>

<pre><code>$kubectl get rc 
NAME           DESIRED   CURRENT   AGE
account        2         2         1h
activity       2         2         1h

</code></pre></li>
<li><p>服务升级：</p>

<pre><code> $[root@ali-k8s-03 rc]# kubectl rolling-update account --image=reg.17mei.top/account/8092af07-account:v1.2.1
 Created account-e041dc4989c5cd11b305bab7075dd2e7
 Scaling up account-e041dc4989c5cd11b305bab7075dd2e7 from 0 to 2, scaling down account from 2 to 0 (keep 2 pods available, don&#39;t exceed 3 pods)
 Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 1
 Scaling account down to 1
 Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 2
 Scaling account down to 0
 Update succeeded. Deleting old controller: account
 Renaming account-e041dc4989c5cd11b305bab7075dd2e7 to account
 replicationcontroller &quot;account&quot; rolling updated
</code></pre>

<ul>
<li>过程解释：首先，k8s创建一个新的RC，名字叫account-e041dc4989c5cd11b305bab7075dd2e7，总数为2个pod，这个过程是保证有两个pods是可用的。最终滚动升级完成。</li>
</ul></li>
<li><p>服务回滚：<br/>
如果发布的过程中发现有问题，那么就需要回滚操作，下面是回滚操作的步骤：</p>

<pre><code>account                                     2         2         47m
activity                                    2         2         2h
activity-db96883e53ab1ed3f11a99ddfbdf31f7   1         1         28m
#此时用activity进行回滚演示，因为已经发布完成的就不能直接回滚，已经发布的回滚相当于一次从新的发布，此时如果想要回滚操作的话就是直接进行下面的操作
$ kubectl rolling-update activity --rollback
</code></pre></li>
</ol></li>
</ol>

<h2 id="toc_2">我是如何进行Kubernetes进行应用的升级的：</h2>

<ol>
<li><p>以上两种方式遇到的问题：</p>

<ul>
<li><p>先说kubernets.</p>

<ol>
<li>Kubernetes滚动升级的方式对于我这种使用配置比较低的机器，速度较慢，时间成本高.</li>
<li>回滚的速度更加的慢，有种想死的冲动。</li>
<li>发到线上测试人员发现问题要立马回滚，搞得大家都很紧张。</li>
</ol></li>
<li><p>再说传统的方式</p>

<ol>
<li>部署速度慢，大公司有专门的代码发布平台，小公司可能就手动发布了。</li>
<li>人工出错情况多，由于一次上线需要很多的步骤所以人为出错的可能性就很高。</li>
<li>因为代码的运行环境问题引发的问题是很难排除的，也许就是一个软件的版本问题。</li>
</ol></li>
<li><p>那么我是如何使用的。</p>

<ol>
<li>双份生产环境（业务量不大，不需要更多的生产环境），production01 和 production02，可以同时使用，也可以有一个备用，看业务量和对业务高可用的要求衡量。</li>
<li>每个微服务有一个yaml配置文件，用来快速升级部署。</li>
<li>升级过程：
  1) 首先将nginx对应组的业务下线，nginx已经做的很好了，能够平滑的下线。
  2) 升级刚才下线的一组服务，过程是删除一组服务，然后重新用新的配置文件上线一组服务。
  3) 刚上线的一组服务可以进行测试。无论测试多久都不会影响。
  4) 测试没有问题之后，可以切换nginx配置将应用上线。</li>
<li>升级过程出现问题回滚：

<ol>
<li>如果发布的过程中发现有问题，那么直接停止升级或者升级完成，因为是在一组下线的生产环境中，都不会发生问题。</li>
</ol></li>
<li>升级成功之后，将另外一组没有升级的线上节点不做任何的处理，防止有Bug要回滚到上一个版本。</li>
</ol></li>
</ul></li>
</ol>

<h2 id="toc_3">总结：</h2>

<pre><code>两个线上环境，快速升级和回滚都有好处。综合了一下传统的升级方式和Kubernetes的升级方式。早安，上海。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 基础]]></title>
    <link href="http://blog.izgnod.com/14719470176268.html"/>
    <updated>2016-08-23T18:10:17+08:00</updated>
    <id>http://blog.izgnod.com/14719470176268.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>服务器响应：</p>

<ol>
<li>1xx 提示信息 - 表示请求被成功接收，继续处理</li>
<li>2xx 成功 - 表示清酒已经被成功接收，理解，接收</li>
<li>3xx 重定向 - 要完成请求必须要做进一步的处理</li>
<li>4xx 客户端错误 - 请求有语法错误或者无法实现</li>
<li>5xx 服务端错误 - 服务端未能实现合法的请求</li>
</ol></li>
<li><p>HTTP协议的无状态和Keep-alive的区别：</p>

<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。<br/>
   从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let's Encrypt 获取Nginx证书]]></title>
    <link href="http://blog.izgnod.com/14719253380529.html"/>
    <updated>2016-08-23T12:08:58+08:00</updated>
    <id>http://blog.izgnod.com/14719253380529.html</id>
    <content type="html"><![CDATA[
<p>Let&#39;s Encrypt作为一个公益项目，给我们带来最大的好处就是能够免费的获取证书，而且申请过程简单，证书有效时间为90天，建议60天的时候主动更新证书。</p>

<hr/>

<h2 id="toc_0">流程以及结果：</h2>

<ol>
<li>安装let&#39;s encrypt 客户端</li>
<li>多个证书申请</li>
<li>定期更新证书</li>
</ol>

<h2 id="toc_1">准备：</h2>

<ol>
<li>首先要有一台nginx服务器</li>
<li>有域名的控制权，也就是可以解析到nginx服务器上</li>
<li>这里使用的是CentOS 7</li>
</ol>

<h2 id="toc_2">流程开始：</h2>

<ol>
<li><p>安装必要的软件</p>

<pre><code> sudo yum -y install git bc
</code></pre></li>
<li><p>安装let&#39;s encrypt 客户端</p>

<pre><code class="language-bash">  $sudo git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt
</code></pre></li>
<li><p>获取证书</p>

<ol>
<li><p>修该nginx 配置文件,在Nginx的/etc/nginx/conf.d/default.conf文件中添加如下的内容。</p>

<pre><code class="language-bash">$ location ~ /.well-known {
allow all;
}
 ```
</code></pre></li>
<li><p>重启nginx</p>

<pre><code class="language-bash">$ sudo systemctl restart nginx
</code></pre></li>
<li><p>申请证书</p>

<pre><code class="language-bash">$ cd /opt/letsencrypt
$./letsencrypt-auto certonly -a webroot --webroot-path=/usr/share/nginx/html -d example.com -d www.example.com
</code></pre>

<p>这里的webroot，我用的是默认的，应为我的nginx是yum直接安装的，如果是自己编译的版本请指定，这样let&#39;s encrypt 才能够验证域名的绝对控制权，-d 后面的参数可以选择多个，但是这几个域名都要解析到本机的nginx上面。</p></li>
<li><p>填写邮箱地址</p>

<ol>
<li><p>注意：这里是let&#39;s encrypt 的客户端的ui界面，只要将你的邮箱地址填入即可，这个邮箱的作用是用来进行账号找回的，也可以下次重新的申请，但是如果要申请的话你要把所有的上面的程序走一遍，但是如果同样的账号，那么至于要一条命令重新的申请以下就好了，比较方便。<br/>
然后一路的同意，最后是输出信息，有Congratulations!等字眼，说明申请已经成功了，注意这时候的输出信息，这些信息中包括了你的证书在什么地方，证书过期证书等。</p></li>
<li><p>输出信息,例如:</p></li>
</ol>

<pre><code class="language-bash">IMPORTANT NOTES:
If you lose your account credentials, you can recover through
e-mails sent to sammy@digitalocean.com
Congratulations! Your certificate and chain have been saved at
/etc/letsencrypt/live/example.com/fullchain.pem. Your
cert will expire on 2016-03-15. To obtain a new version of the
certificate in the future, simply run Let&#39;s Encrypt again.
Your account credentials have been saved in your Let&#39;s Encrypt
configuration directory at /etc/letsencrypt. You should make a
secure backup of this folder now. This configuration directory will
also contain certificates and private keys obtained by Let&#39;s
Encrypt so making regular backups of this folder is ideal.
If like Let&#39;s Encrypt, please consider supporting our work by:

Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
Donating to EFF:                    https://eff.org/donate-len
</code></pre>

<ol>
<li><p>申请之后的产物</p>

<ul>
<li>cert.pem 这个就是域名的证书，Nginx 需要。</li>
<li>privkey.pem 这个是秘钥,Nginx 需要。</li>
<li>chain.pem 这信任let&#39;s encrypt 的证书。</li>
<li>fullchain.pem 这个是cert.pem 和 chain.pem证书的结合体。</li>
<li>chain.pem 这是是一个let&#39;s Encrypt 用来找回证书的一个标志文件</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>Nginx 配置使用证书：</p>

<p>在对应的域名的配置文件中加入：</p>

<pre><code>listen 443 ssl;
server_name example.com www.example.com;
ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
</code></pre></li>
<li><p>重启nginx，并且https请求。</p></li>
<li><p>定时任务，每周进行一次证书的申请以及重启nginx</p>

<pre><code> $sudo crontab -e
</code></pre>

<p>添加如下定时任务： </p>

<pre><code>  30 2 * * 1 /opt/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/log/le-renew.log
  35 2 * * 1 /usr/bin/systemctl reload nginx
</code></pre></li>
</ol>

<h2 id="toc_3">总结:以上步骤很简单，并且很好用，如果以后需要升级let&#39;s encrypt客户端软件，直接git pull即可，非常方便。</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Registry]]></title>
    <link href="http://blog.izgnod.com/14719166233226.html"/>
    <updated>2016-08-23T09:43:43+08:00</updated>
    <id>http://blog.izgnod.com/14719166233226.html</id>
    <content type="html"><![CDATA[
<ol>
<li>安全问题：能够在不泄露公司代码的情况下，存储镜像</li>
<li>可用性： 不依赖其他的第三方的docker仓库</li>
<li>Ci： 公司部署方式的改变，Docker Registry成为不可或缺的一部分。</li>
</ol>

<h2 id="toc_0">搭建准备：</h2>

<ol>
<li>镜像：registry:2</li>
<li>镜像存储的目录：例如：/DockerRegistry/</li>
<li>证书,安全证书</li>
</ol>

<h2 id="toc_1">搭建过程：</h2>

<ol>
<li>首先拉取Docker Registry镜像(由于国内墙的问题,使用DaoCloud镜像)<br/></li>
</ol>

<pre><code>docker pull daocloud.io/library/registry:2.4.1
</code></pre>

<ol>
<li>创建镜像存储目录：</li>
</ol>

<pre><code>$mkdir /DockerRegistry/
</code></pre>

<ol>
<li>创建证书文件目录并且放入证书：</li>
</ol>

<pre><code>$mkdir /DockerRegistry/cert 
</code></pre>

<ol>
<li>创建Docker Registry登录密码：</li>
</ol>

<pre><code class="language-bash">$mkdir auth
$docker run --entrypoint htpasswd daocloud.io/library/registry:2.4.1  -Bbn testuser testpassword &gt; auth/htpasswd
</code></pre>

<ol>
<li>启动Registry (注意下面的证书都是要改为自己的证书)</li>
</ol>

<pre><code class="language-bash">$docker run -d -p 5000:5000 --restart=always --name registry \
  -v `pwd`/auth:/auth \
  -e &quot;REGISTRY_AUTH=htpasswd&quot; \
  -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
  daocloud.io/library/registry:2.4.1
</code></pre>

<ol>
<li>添加一个可视化的界面 </li>
</ol>

<pre><code class="language-bash">$docker run \
  -d \
  -e ENV_DOCKER_REGISTRY_HOST=ENTER-YOUR-REGISTRY-HOST-HERE \
  -e ENV_DOCKER_REGISTRY_PORT=ENTER-PORT-TO-YOUR-REGISTRY-HOST-HERE \
  -e ENV_MODE_BROWSE_ONLY=false
  -p 8080:80 \
  konradkleine/docker-registry-frontend:v2
</code></pre>

<ol>
<li>nginx配置 (添加nginx配置)</li>
</ol>

<pre><code class="language-nginx.conf">$server {
    server_name dev;
    location / {
        proxy_pass http://x.x.x.x:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection &quot;&quot;;
    }
}
</code></pre>

<h2 id="toc_2">总结：</h2>

<p>以上的步骤比较简单，已经满足大部分的需求，更加高端的需求可以定制registry的config.yaml文件。<br/>
起始可以在第六步的时候不必要映射端口到host，包括第七部也可以不用，因为相同在同一台机器上的docker是可以直接连接。</p>

]]></content>
  </entry>
  
</feed>
