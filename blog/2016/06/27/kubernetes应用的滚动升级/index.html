<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Kubernetes应用的滚动升级 - izgnod 技术男的剑舞人生</title>
    <meta charset="utf-8" />
    <meta name="author" content="武向东" />
    <meta name="description" content="Kubernets App Rolling update" />
    <meta name="keywords" content="Kubernets" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">izgnod 技术男的剑舞人生</a></h1>
        <p>================&gt; 剑能杀人，也能做舞</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/FuckAll/FuckAll.github.io">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="FuckAll.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Kubernetes应用的滚动升级</h1>


<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">传统的高可用步骤：</h2>
<div class="outline-text-2" id="text-orgheadline1">
<ol class="org-ol">
<li>将版本的业务进行启动</li>
<li>切换nginx等的配置，切换生产环境</li>
<li>检查上线代码是否有问题</li>
<li>如果没有问题就继续，如果有问题快速的切换配置，将版本快速的回退到上一个版本。</li>
</ol>
<p>
这样做的优缺点：
</p>
<ul class="org-ul">
<li>先说优点
<ul class="org-ul">
<li>回滚速度快，能够在第一时间发现错误.</li>
</ul></li>
<li>再说缺点：
<ul class="org-ul">
<li>过多的人工操作，导致人为失误很大程度上影响发布质量。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Kubernetes 方式滚动升级：</h2>
<div class="outline-text-2" id="text-orgheadline2">
<ol class="org-ol">
<li>升级过程：
<ul class="org-ul">
<li>和传统的滚动升级的思路是一样的，即将新的pod升级上去，然后慢慢的将旧的pod数量降到0，从而实现升级。</li>
</ul></li>
<li>下面演示升级过程：
<ol class="org-ol">
<li><p>
本地微服务：
</p>
<div class="org-src-container">

<pre class="src src-shell">$kubectl get rc 
 NAME           DESIRED   CURRENT   AGE
 account        2         2         1h
 activity       2         2         1h
 #例如有以上两个微服务
</pre>
</div></li>
<li><p>
服务升级：
</p>
<div class="org-src-container">

<pre class="src src-shell">#例如account微服务
$[root@ali-k8s-03 rc]# kubectl rolling-update account --image=reg.17mei.top/account/8092af07-account:v1.2.1
Created account-e041dc4989c5cd11b305bab7075dd2e7
Scaling up account-e041dc4989c5cd11b305bab7075dd2e7 from 0 to 2, scaling down account from 2 to 0 (keep 2 pods available, don't exceed 3 pods)
Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 1
Scaling account down to 1
Scaling account-e041dc4989c5cd11b305bab7075dd2e7 up to 2
Scaling account down to 0
Update succeeded. Deleting old controller: account
Renaming account-e041dc4989c5cd11b305bab7075dd2e7 to account
replicationcontroller "account" rolling updated
</pre>
</div>
<ul class="org-ul">
<li>过程解释：首先，k8s创建一个新的RC，名字叫account-e041dc4989c5cd11b305bab7075dd2e7，总数为2个pod，这个过程是保证有两个pods是可用的。最终滚动升级完成。</li>
</ul></li>
<li>服务回滚：
<ul class="org-ul">
<li><p>
如果发布的过程中发现有问题，那么就需要回滚操作，下面是回滚操作的步骤：
</p>
<div class="org-src-container">

<pre class="src src-shell">account                                     2         2         47m
activity                                    2         2         2h
activity-db96883e53ab1ed3f11a99ddfbdf31f7   1         1         28m
#此时用activity进行回滚演示，因为已经发布完成的就不能直接回滚，已经发布的回滚相当于一次从新的发布，此时如果想要回滚操作的话就是直接进行下面的操作
$ kubectl rolling-update activity --rollback
</pre>
</div></li>
</ul></li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">我是如何进行Kubernetes进行应用的升级的：</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
1.以上两种方式遇到的问题：
</p>
<ul class="org-ul">
<li>先说kubernets.
<ol class="org-ol">
<li>Kubernetes滚动升级的方式对于我这种使用配置比较低的机器，速度较慢，时间成本高.</li>
<li>回滚的速度更加的慢，有种想死的冲动。</li>
<li>发到线上测试人员发现问题要立马回滚，搞得大家都很紧张。</li>
</ol></li>
<li>再说传统的方式
<ol class="org-ol">
<li>部署速度慢，大公司有专门的代码发布平台，小公司可能就手动发布了。</li>
<li>人工出错情况多，由于一次上线需要很多的步骤所以人为出错的可能性就很高。</li>
<li>因为代码的运行环境问题引发的问题是很难排除的，也许就是一个软件的版本问题。</li>
</ol></li>
<li>那么我是如何使用的。
<ol class="org-ol">
<li>双份生产环境（业务量不大，不需要更多的生产环境），production01 和 production02，可以同时使用，也可以有一个备用，看业务量和对业务高可用的要求衡量。</li>
<li>每个微服务有一个yaml配置文件，用来快速升级部署。</li>
<li>升级过程：
<ol class="org-ol">
<li>首先将nginx对应组的业务下线，nginx已经做的很好了，能够平滑的下线。</li>
<li>升级刚才下线的一组服务，过程是删除一组服务，然后重新用新的配置文件上线一组服务。</li>
<li>刚上线的一组服务可以进行测试。无论测试多久都不会影响。</li>
<li>测试没有问题之后，可以切换nginx配置将应用上线。</li>
</ol></li>
<li>升级过程出现问题回滚：
<ol class="org-ol">
<li>如果发布的过程中发现有问题，那么直接停止升级或者升级完成，因为是在一组下线的生产环境中，都不会发生问题。</li>
</ol></li>
<li>升级成功之后，将另外一组没有升级的线上节点不做任何的处理，防止有Bug要回滚到上一个版本。</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">总结：</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
两个线上环境，快速升级和回滚都有好处。综合了一下传统的升级方式和Kubernetes的升级方式。早安，上海。
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2016-06-27</span>
        <span title="last modification date" class="post-info">2016-06-28</span>
        <span title="tags" class="post-info"><a href="/tags/kubernets/">Kubernets</a></span>
        <span title="author" class="post-info">武向东</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2016/06/27/kubernetes应用的滚动升级";
          var disqus_url = "https://FuckAll.github.io/blog/2016/06/27/kubernetes应用的滚动升级";
          var disqus_shortname = 'izgnod';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:KongFu &lt;at&gt; Battleplane &lt;dot&gt; local">武向东</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
